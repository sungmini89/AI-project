import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module) {
    !(function(t, n) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    })(exports, (function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    }));
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    !(function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    })(exports, (function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = (function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = (function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          })(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, (function(t3, r3) {
            return r3 || (function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            })(t3) || i2.replace(":", "");
          }));
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      })(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach((function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      })), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    }));
  }
});

// node_modules/chrono-node/dist/esm/locales/en/index.js
var en_exports = {};
__export(en_exports, {
  Chrono: () => Chrono,
  GB: () => GB,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual,
  configuration: () => configuration,
  parse: () => parse,
  parseDate: () => parseDate,
  strict: () => strict
});

// node_modules/chrono-node/dist/esm/results.js
var import_quarterOfYear = __toESM(require_quarterOfYear(), 1);
var import_dayjs2 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/types.js
var Meridiem;
(function(Meridiem2) {
  Meridiem2[Meridiem2["AM"] = 0] = "AM";
  Meridiem2[Meridiem2["PM"] = 1] = "PM";
})(Meridiem || (Meridiem = {}));
var Weekday;
(function(Weekday2) {
  Weekday2[Weekday2["SUNDAY"] = 0] = "SUNDAY";
  Weekday2[Weekday2["MONDAY"] = 1] = "MONDAY";
  Weekday2[Weekday2["TUESDAY"] = 2] = "TUESDAY";
  Weekday2[Weekday2["WEDNESDAY"] = 3] = "WEDNESDAY";
  Weekday2[Weekday2["THURSDAY"] = 4] = "THURSDAY";
  Weekday2[Weekday2["FRIDAY"] = 5] = "FRIDAY";
  Weekday2[Weekday2["SATURDAY"] = 6] = "SATURDAY";
})(Weekday || (Weekday = {}));
var Month;
(function(Month2) {
  Month2[Month2["JANUARY"] = 1] = "JANUARY";
  Month2[Month2["FEBRUARY"] = 2] = "FEBRUARY";
  Month2[Month2["MARCH"] = 3] = "MARCH";
  Month2[Month2["APRIL"] = 4] = "APRIL";
  Month2[Month2["MAY"] = 5] = "MAY";
  Month2[Month2["JUNE"] = 6] = "JUNE";
  Month2[Month2["JULY"] = 7] = "JULY";
  Month2[Month2["AUGUST"] = 8] = "AUGUST";
  Month2[Month2["SEPTEMBER"] = 9] = "SEPTEMBER";
  Month2[Month2["OCTOBER"] = 10] = "OCTOBER";
  Month2[Month2["NOVEMBER"] = 11] = "NOVEMBER";
  Month2[Month2["DECEMBER"] = 12] = "DECEMBER";
})(Month || (Month = {}));

// node_modules/chrono-node/dist/esm/utils/dates.js
function assignSimilarDate(component, target) {
  component.assign("day", target.getDate());
  component.assign("month", target.getMonth() + 1);
  component.assign("year", target.getFullYear());
}
function assignSimilarTime(component, target) {
  component.assign("hour", target.getHours());
  component.assign("minute", target.getMinutes());
  component.assign("second", target.getSeconds());
  component.assign("millisecond", target.getMilliseconds());
  component.assign("meridiem", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);
}
function implySimilarDate(component, target) {
  component.imply("day", target.getDate());
  component.imply("month", target.getMonth() + 1);
  component.imply("year", target.getFullYear());
}
function implySimilarTime(component, target) {
  component.imply("hour", target.getHours());
  component.imply("minute", target.getMinutes());
  component.imply("second", target.getSeconds());
  component.imply("millisecond", target.getMilliseconds());
  component.imply("meridiem", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);
}

// node_modules/chrono-node/dist/esm/timezone.js
var import_dayjs = __toESM(require_dayjs_min(), 1);
var TIMEZONE_ABBR_MAP = {
  ACDT: 630,
  ACST: 570,
  ADT: -180,
  AEDT: 660,
  AEST: 600,
  AFT: 270,
  AKDT: -480,
  AKST: -540,
  ALMT: 360,
  AMST: -180,
  AMT: -240,
  ANAST: 720,
  ANAT: 720,
  AQTT: 300,
  ART: -180,
  AST: -240,
  AWDT: 540,
  AWST: 480,
  AZOST: 0,
  AZOT: -60,
  AZST: 300,
  AZT: 240,
  BNT: 480,
  BOT: -240,
  BRST: -120,
  BRT: -180,
  BST: 60,
  BTT: 360,
  CAST: 480,
  CAT: 120,
  CCT: 390,
  CDT: -300,
  CEST: 120,
  CET: {
    timezoneOffsetDuringDst: 2 * 60,
    timezoneOffsetNonDst: 60,
    dstStart: (year3) => getLastWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2),
    dstEnd: (year3) => getLastWeekdayOfMonth(year3, Month.OCTOBER, Weekday.SUNDAY, 3)
  },
  CHADT: 825,
  CHAST: 765,
  CKT: -600,
  CLST: -180,
  CLT: -240,
  COT: -300,
  CST: -360,
  CT: {
    timezoneOffsetDuringDst: -5 * 60,
    timezoneOffsetNonDst: -6 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  CVT: -60,
  CXT: 420,
  ChST: 600,
  DAVT: 420,
  EASST: -300,
  EAST: -360,
  EAT: 180,
  ECT: -300,
  EDT: -240,
  EEST: 180,
  EET: 120,
  EGST: 0,
  EGT: -60,
  EST: -300,
  ET: {
    timezoneOffsetDuringDst: -4 * 60,
    timezoneOffsetNonDst: -5 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  FJST: 780,
  FJT: 720,
  FKST: -180,
  FKT: -240,
  FNT: -120,
  GALT: -360,
  GAMT: -540,
  GET: 240,
  GFT: -180,
  GILT: 720,
  GMT: 0,
  GST: 240,
  GYT: -240,
  HAA: -180,
  HAC: -300,
  HADT: -540,
  HAE: -240,
  HAP: -420,
  HAR: -360,
  HAST: -600,
  HAT: -90,
  HAY: -480,
  HKT: 480,
  HLV: -210,
  HNA: -240,
  HNC: -360,
  HNE: -300,
  HNP: -480,
  HNR: -420,
  HNT: -150,
  HNY: -540,
  HOVT: 420,
  ICT: 420,
  IDT: 180,
  IOT: 360,
  IRDT: 270,
  IRKST: 540,
  IRKT: 540,
  IRST: 210,
  IST: 330,
  JST: 540,
  KGT: 360,
  KRAST: 480,
  KRAT: 480,
  KST: 540,
  KUYT: 240,
  LHDT: 660,
  LHST: 630,
  LINT: 840,
  MAGST: 720,
  MAGT: 720,
  MART: -510,
  MAWT: 300,
  MDT: -360,
  MESZ: 120,
  MEZ: 60,
  MHT: 720,
  MMT: 390,
  MSD: 240,
  MSK: 180,
  MST: -420,
  MT: {
    timezoneOffsetDuringDst: -6 * 60,
    timezoneOffsetNonDst: -7 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  MUT: 240,
  MVT: 300,
  MYT: 480,
  NCT: 660,
  NDT: -90,
  NFT: 690,
  NOVST: 420,
  NOVT: 360,
  NPT: 345,
  NST: -150,
  NUT: -660,
  NZDT: 780,
  NZST: 720,
  OMSST: 420,
  OMST: 420,
  PDT: -420,
  PET: -300,
  PETST: 720,
  PETT: 720,
  PGT: 600,
  PHOT: 780,
  PHT: 480,
  PKT: 300,
  PMDT: -120,
  PMST: -180,
  PONT: 660,
  PST: -480,
  PT: {
    timezoneOffsetDuringDst: -7 * 60,
    timezoneOffsetNonDst: -8 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  PWT: 540,
  PYST: -180,
  PYT: -240,
  RET: 240,
  SAMT: 240,
  SAST: 120,
  SBT: 660,
  SCT: 240,
  SGT: 480,
  SRT: -180,
  SST: -660,
  TAHT: -600,
  TFT: 300,
  TJT: 300,
  TKT: 780,
  TLT: 540,
  TMT: 300,
  TVT: 720,
  ULAT: 480,
  UTC: 0,
  UYST: -120,
  UYT: -180,
  UZT: 300,
  VET: -210,
  VLAST: 660,
  VLAT: 660,
  VUT: 660,
  WAST: 120,
  WAT: 60,
  WEST: 60,
  WESZ: 60,
  WET: 0,
  WEZ: 0,
  WFT: 720,
  WGST: -120,
  WGT: -180,
  WIB: 420,
  WIT: 540,
  WITA: 480,
  WST: 780,
  WT: 0,
  YAKST: 600,
  YAKT: 600,
  YAPT: 600,
  YEKST: 360,
  YEKT: 360
};
function getNthWeekdayOfMonth(year3, month, weekday, n, hour = 0) {
  let dayOfMonth = 0;
  let i = 0;
  while (i < n) {
    dayOfMonth++;
    const date = new Date(year3, month - 1, dayOfMonth);
    if (date.getDay() === weekday)
      i++;
  }
  return new Date(year3, month - 1, dayOfMonth, hour);
}
function getLastWeekdayOfMonth(year3, month, weekday, hour = 0) {
  const oneIndexedWeekday = weekday === 0 ? 7 : weekday;
  const date = new Date(year3, month - 1 + 1, 1, 12);
  const firstWeekdayNextMonth = date.getDay() === 0 ? 7 : date.getDay();
  let dayDiff;
  if (firstWeekdayNextMonth === oneIndexedWeekday)
    dayDiff = 7;
  else if (firstWeekdayNextMonth < oneIndexedWeekday)
    dayDiff = 7 + firstWeekdayNextMonth - oneIndexedWeekday;
  else
    dayDiff = firstWeekdayNextMonth - oneIndexedWeekday;
  date.setDate(date.getDate() - dayDiff);
  return new Date(year3, month - 1, date.getDate(), hour);
}
function toTimezoneOffset(timezoneInput, date, timezoneOverrides = {}) {
  if (timezoneInput == null) {
    return null;
  }
  if (typeof timezoneInput === "number") {
    return timezoneInput;
  }
  const matchedTimezone = timezoneOverrides[timezoneInput] ?? TIMEZONE_ABBR_MAP[timezoneInput];
  if (matchedTimezone == null) {
    return null;
  }
  if (typeof matchedTimezone == "number") {
    return matchedTimezone;
  }
  if (date == null) {
    return null;
  }
  if ((0, import_dayjs.default)(date).isAfter(matchedTimezone.dstStart(date.getFullYear())) && !(0, import_dayjs.default)(date).isAfter(matchedTimezone.dstEnd(date.getFullYear()))) {
    return matchedTimezone.timezoneOffsetDuringDst;
  }
  return matchedTimezone.timezoneOffsetNonDst;
}

// node_modules/chrono-node/dist/esm/calculation/duration.js
function addDuration(ref, duration) {
  let date = new Date(ref);
  if (duration["y"]) {
    duration["year"] = duration["y"];
    delete duration["y"];
  }
  if (duration["mo"]) {
    duration["month"] = duration["mo"];
    delete duration["mo"];
  }
  if (duration["M"]) {
    duration["month"] = duration["M"];
    delete duration["M"];
  }
  if (duration["w"]) {
    duration["week"] = duration["w"];
    delete duration["w"];
  }
  if (duration["d"]) {
    duration["day"] = duration["d"];
    delete duration["d"];
  }
  if (duration["h"]) {
    duration["hour"] = duration["h"];
    delete duration["h"];
  }
  if (duration["m"]) {
    duration["minute"] = duration["m"];
    delete duration["m"];
  }
  if (duration["s"]) {
    duration["second"] = duration["s"];
    delete duration["s"];
  }
  if (duration["ms"]) {
    duration["millisecond"] = duration["ms"];
    delete duration["ms"];
  }
  if ("year" in duration) {
    const floor = Math.floor(duration["year"]);
    date.setFullYear(date.getFullYear() + floor);
    const remainingFraction = duration["year"] - floor;
    if (remainingFraction > 0) {
      duration.month = duration?.month ?? 0;
      duration.month += remainingFraction * 12;
    }
  }
  if ("quarter" in duration) {
    const floor = Math.floor(duration["quarter"]);
    date.setMonth(date.getMonth() + floor * 3);
  }
  if ("month" in duration) {
    const floor = Math.floor(duration["month"]);
    date.setMonth(date.getMonth() + floor);
    const remainingFraction = duration["month"] - floor;
    if (remainingFraction > 0) {
      duration.week = duration?.week ?? 0;
      duration.week += remainingFraction * 4;
    }
  }
  if ("week" in duration) {
    const floor = Math.floor(duration["week"]);
    date.setDate(date.getDate() + floor * 7);
    const remainingFraction = duration["week"] - floor;
    if (remainingFraction > 0) {
      duration.day = duration?.day ?? 0;
      duration.day += Math.round(remainingFraction * 7);
    }
  }
  if ("day" in duration) {
    const floor = Math.floor(duration["day"]);
    date.setDate(date.getDate() + floor);
    const remainingFraction = duration["day"] - floor;
    if (remainingFraction > 0) {
      duration.hour = duration?.hour ?? 0;
      duration.hour += Math.round(remainingFraction * 24);
    }
  }
  if ("hour" in duration) {
    const floor = Math.floor(duration["hour"]);
    date.setHours(date.getHours() + floor);
    const remainingFraction = duration["hour"] - floor;
    if (remainingFraction > 0) {
      duration.minute = duration?.minute ?? 0;
      duration.minute += Math.round(remainingFraction * 60);
    }
  }
  if ("minute" in duration) {
    const floor = Math.floor(duration["minute"]);
    date.setMinutes(date.getMinutes() + floor);
    const remainingFraction = duration["minute"] - floor;
    if (remainingFraction > 0) {
      duration.second = duration?.second ?? 0;
      duration.second += Math.round(remainingFraction * 60);
    }
  }
  if ("second" in duration) {
    const floor = Math.floor(duration["second"]);
    date.setSeconds(date.getSeconds() + floor);
    const remainingFraction = duration["second"] - floor;
    if (remainingFraction > 0) {
      duration.millisecond = duration?.millisecond ?? 0;
      duration.millisecond += Math.round(remainingFraction * 1e3);
    }
  }
  if ("millisecond" in duration) {
    const floor = Math.floor(duration["millisecond"]);
    date.setMilliseconds(date.getMilliseconds() + floor);
  }
  return date;
}
function reverseDuration(duration) {
  const reversed = {};
  for (const key in duration) {
    reversed[key] = -duration[key];
  }
  return reversed;
}

// node_modules/chrono-node/dist/esm/results.js
import_dayjs2.default.extend(import_quarterOfYear.default);
var ReferenceWithTimezone = class _ReferenceWithTimezone {
  instant;
  timezoneOffset;
  constructor(instant, timezoneOffset) {
    this.instant = instant ?? /* @__PURE__ */ new Date();
    this.timezoneOffset = timezoneOffset ?? null;
  }
  static fromDate(date) {
    return new _ReferenceWithTimezone(date);
  }
  static fromInput(input, timezoneOverrides) {
    if (input instanceof Date) {
      return _ReferenceWithTimezone.fromDate(input);
    }
    const instant = input?.instant ?? /* @__PURE__ */ new Date();
    const timezoneOffset = toTimezoneOffset(input?.timezone, instant, timezoneOverrides);
    return new _ReferenceWithTimezone(instant, timezoneOffset);
  }
  getDateWithAdjustedTimezone() {
    const date = new Date(this.instant);
    if (this.timezoneOffset !== null) {
      date.setMinutes(date.getMinutes() - this.getSystemTimezoneAdjustmentMinute(this.instant));
    }
    return date;
  }
  getSystemTimezoneAdjustmentMinute(date, overrideTimezoneOffset) {
    if (!date || date.getTime() < 0) {
      date = /* @__PURE__ */ new Date();
    }
    const currentTimezoneOffset = -date.getTimezoneOffset();
    const targetTimezoneOffset = overrideTimezoneOffset ?? this.timezoneOffset ?? currentTimezoneOffset;
    return currentTimezoneOffset - targetTimezoneOffset;
  }
  getTimezoneOffset() {
    return this.timezoneOffset ?? -this.instant.getTimezoneOffset();
  }
};
var ParsingComponents = class _ParsingComponents {
  knownValues;
  impliedValues;
  reference;
  _tags = /* @__PURE__ */ new Set();
  constructor(reference, knownComponents) {
    this.reference = reference;
    this.knownValues = {};
    this.impliedValues = {};
    if (knownComponents) {
      for (const key in knownComponents) {
        this.knownValues[key] = knownComponents[key];
      }
    }
    const refDayJs = reference.getDateWithAdjustedTimezone();
    this.imply("day", refDayJs.getDate());
    this.imply("month", refDayJs.getMonth() + 1);
    this.imply("year", refDayJs.getFullYear());
    this.imply("hour", 12);
    this.imply("minute", 0);
    this.imply("second", 0);
    this.imply("millisecond", 0);
  }
  get(component) {
    if (component in this.knownValues) {
      return this.knownValues[component];
    }
    if (component in this.impliedValues) {
      return this.impliedValues[component];
    }
    return null;
  }
  isCertain(component) {
    return component in this.knownValues;
  }
  getCertainComponents() {
    return Object.keys(this.knownValues);
  }
  imply(component, value) {
    if (component in this.knownValues) {
      return this;
    }
    this.impliedValues[component] = value;
    return this;
  }
  assign(component, value) {
    this.knownValues[component] = value;
    delete this.impliedValues[component];
    return this;
  }
  delete(component) {
    delete this.knownValues[component];
    delete this.impliedValues[component];
  }
  clone() {
    const component = new _ParsingComponents(this.reference);
    component.knownValues = {};
    component.impliedValues = {};
    for (const key in this.knownValues) {
      component.knownValues[key] = this.knownValues[key];
    }
    for (const key in this.impliedValues) {
      component.impliedValues[key] = this.impliedValues[key];
    }
    return component;
  }
  isOnlyDate() {
    return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
  }
  isOnlyTime() {
    return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month") && !this.isCertain("year");
  }
  isOnlyWeekdayComponent() {
    return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
  }
  isDateWithUnknownYear() {
    return this.isCertain("month") && !this.isCertain("year");
  }
  isValidDate() {
    const date = this.dateWithoutTimezoneAdjustment();
    if (date.getFullYear() !== this.get("year"))
      return false;
    if (date.getMonth() !== this.get("month") - 1)
      return false;
    if (date.getDate() !== this.get("day"))
      return false;
    if (this.get("hour") != null && date.getHours() != this.get("hour"))
      return false;
    if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
      return false;
    return true;
  }
  toString() {
    return `[ParsingComponents {
            tags: ${JSON.stringify(Array.from(this._tags).sort())}, 
            knownValues: ${JSON.stringify(this.knownValues)}, 
            impliedValues: ${JSON.stringify(this.impliedValues)}}, 
            reference: ${JSON.stringify(this.reference)}]`;
  }
  dayjs() {
    return (0, import_dayjs2.default)(this.dateWithoutTimezoneAdjustment());
  }
  date() {
    const date = this.dateWithoutTimezoneAdjustment();
    const timezoneAdjustment = this.reference.getSystemTimezoneAdjustmentMinute(date, this.get("timezoneOffset"));
    return new Date(date.getTime() + timezoneAdjustment * 6e4);
  }
  addTag(tag) {
    this._tags.add(tag);
    return this;
  }
  addTags(tags) {
    for (const tag of tags) {
      this._tags.add(tag);
    }
    return this;
  }
  tags() {
    return new Set(this._tags);
  }
  dateWithoutTimezoneAdjustment() {
    const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
    date.setFullYear(this.get("year"));
    return date;
  }
  static createRelativeFromReference(reference, duration) {
    let date = addDuration(reference.getDateWithAdjustedTimezone(), duration);
    const components = new _ParsingComponents(reference);
    components.addTag("result/relativeDate");
    if (duration["hour"] || duration["minute"] || duration["second"]) {
      components.addTag("result/relativeDateAndTime");
      assignSimilarTime(components, date);
      assignSimilarDate(components, date);
      components.assign("timezoneOffset", reference.getTimezoneOffset());
    } else {
      implySimilarTime(components, date);
      components.imply("timezoneOffset", reference.getTimezoneOffset());
      if (duration["day"]) {
        components.assign("day", date.getDate());
        components.assign("month", date.getMonth() + 1);
        components.assign("year", date.getFullYear());
        components.assign("weekday", date.getDay());
      } else if (duration["week"]) {
        components.assign("day", date.getDate());
        components.assign("month", date.getMonth() + 1);
        components.assign("year", date.getFullYear());
        components.imply("weekday", date.getDay());
      } else {
        components.imply("day", date.getDate());
        if (duration["month"]) {
          components.assign("month", date.getMonth() + 1);
          components.assign("year", date.getFullYear());
        } else {
          components.imply("month", date.getMonth() + 1);
          if (duration["year"]) {
            components.assign("year", date.getFullYear());
          } else {
            components.imply("year", date.getFullYear());
          }
        }
      }
    }
    return components;
  }
};
var ParsingResult = class _ParsingResult {
  refDate;
  index;
  text;
  reference;
  start;
  end;
  constructor(reference, index, text, start, end) {
    this.reference = reference;
    this.refDate = reference.instant;
    this.index = index;
    this.text = text;
    this.start = start || new ParsingComponents(reference);
    this.end = end;
  }
  clone() {
    const result = new _ParsingResult(this.reference, this.index, this.text);
    result.start = this.start ? this.start.clone() : null;
    result.end = this.end ? this.end.clone() : null;
    return result;
  }
  date() {
    return this.start.date();
  }
  addTag(tag) {
    this.start.addTag(tag);
    if (this.end) {
      this.end.addTag(tag);
    }
    return this;
  }
  addTags(tags) {
    this.start.addTags(tags);
    if (this.end) {
      this.end.addTags(tags);
    }
    return this;
  }
  tags() {
    const combinedTags = new Set(this.start.tags());
    if (this.end) {
      for (const tag of this.end.tags()) {
        combinedTags.add(tag);
      }
    }
    return combinedTags;
  }
  toString() {
    const tags = Array.from(this.tags()).sort();
    return `[ParsingResult {index: ${this.index}, text: '${this.text}', tags: ${JSON.stringify(tags)} ...}]`;
  }
};

// node_modules/chrono-node/dist/esm/utils/pattern.js
function repeatedTimeunitPattern(prefix, singleTimeunitPattern, connectorPattern = "\\s{0,5},?\\s{0,5}") {
  const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
  return `${prefix}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;
}
function extractTerms(dictionary) {
  let keys;
  if (dictionary instanceof Array) {
    keys = [...dictionary];
  } else if (dictionary instanceof Map) {
    keys = Array.from(dictionary.keys());
  } else {
    keys = Object.keys(dictionary);
  }
  return keys;
}
function matchAnyPattern(dictionary) {
  const joinedTerms = extractTerms(dictionary).sort((a, b) => b.length - a.length).join("|").replace(/\./g, "\\.");
  return `(?:${joinedTerms})`;
}

// node_modules/chrono-node/dist/esm/calculation/years.js
var import_dayjs3 = __toESM(require_dayjs_min(), 1);
function findMostLikelyADYear(yearNumber) {
  if (yearNumber < 100) {
    if (yearNumber > 50) {
      yearNumber = yearNumber + 1900;
    } else {
      yearNumber = yearNumber + 2e3;
    }
  }
  return yearNumber;
}
function findYearClosestToRef(refDate, day, month) {
  const refMoment = (0, import_dayjs3.default)(refDate);
  let dateMoment = refMoment;
  dateMoment = dateMoment.month(month - 1);
  dateMoment = dateMoment.date(day);
  dateMoment = dateMoment.year(refMoment.year());
  const nextYear = dateMoment.add(1, "y");
  const lastYear = dateMoment.add(-1, "y");
  if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
    dateMoment = nextYear;
  } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
    dateMoment = lastYear;
  }
  return dateMoment.year();
}

// node_modules/chrono-node/dist/esm/locales/en/constants.js
var WEEKDAY_DICTIONARY = {
  sunday: 0,
  sun: 0,
  "sun.": 0,
  monday: 1,
  mon: 1,
  "mon.": 1,
  tuesday: 2,
  tue: 2,
  "tue.": 2,
  wednesday: 3,
  wed: 3,
  "wed.": 3,
  thursday: 4,
  thurs: 4,
  "thurs.": 4,
  thur: 4,
  "thur.": 4,
  thu: 4,
  "thu.": 4,
  friday: 5,
  fri: 5,
  "fri.": 5,
  saturday: 6,
  sat: 6,
  "sat.": 6
};
var FULL_MONTH_NAME_DICTIONARY = {
  january: 1,
  february: 2,
  march: 3,
  april: 4,
  may: 5,
  june: 6,
  july: 7,
  august: 8,
  september: 9,
  october: 10,
  november: 11,
  december: 12
};
var MONTH_DICTIONARY = {
  ...FULL_MONTH_NAME_DICTIONARY,
  jan: 1,
  "jan.": 1,
  feb: 2,
  "feb.": 2,
  mar: 3,
  "mar.": 3,
  apr: 4,
  "apr.": 4,
  jun: 6,
  "jun.": 6,
  jul: 7,
  "jul.": 7,
  aug: 8,
  "aug.": 8,
  sep: 9,
  "sep.": 9,
  sept: 9,
  "sept.": 9,
  oct: 10,
  "oct.": 10,
  nov: 11,
  "nov.": 11,
  dec: 12,
  "dec.": 12
};
var INTEGER_WORD_DICTIONARY = {
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  six: 6,
  seven: 7,
  eight: 8,
  nine: 9,
  ten: 10,
  eleven: 11,
  twelve: 12
};
var ORDINAL_WORD_DICTIONARY = {
  first: 1,
  second: 2,
  third: 3,
  fourth: 4,
  fifth: 5,
  sixth: 6,
  seventh: 7,
  eighth: 8,
  ninth: 9,
  tenth: 10,
  eleventh: 11,
  twelfth: 12,
  thirteenth: 13,
  fourteenth: 14,
  fifteenth: 15,
  sixteenth: 16,
  seventeenth: 17,
  eighteenth: 18,
  nineteenth: 19,
  twentieth: 20,
  "twenty first": 21,
  "twenty-first": 21,
  "twenty second": 22,
  "twenty-second": 22,
  "twenty third": 23,
  "twenty-third": 23,
  "twenty fourth": 24,
  "twenty-fourth": 24,
  "twenty fifth": 25,
  "twenty-fifth": 25,
  "twenty sixth": 26,
  "twenty-sixth": 26,
  "twenty seventh": 27,
  "twenty-seventh": 27,
  "twenty eighth": 28,
  "twenty-eighth": 28,
  "twenty ninth": 29,
  "twenty-ninth": 29,
  "thirtieth": 30,
  "thirty first": 31,
  "thirty-first": 31
};
var TIME_UNIT_DICTIONARY_NO_ABBR = {
  second: "second",
  seconds: "second",
  minute: "minute",
  minutes: "minute",
  hour: "hour",
  hours: "hour",
  day: "d",
  days: "d",
  week: "week",
  weeks: "week",
  month: "month",
  months: "month",
  quarter: "quarter",
  quarters: "quarter",
  year: "year",
  years: "year"
};
var TIME_UNIT_DICTIONARY = {
  s: "second",
  sec: "second",
  second: "second",
  seconds: "second",
  m: "minute",
  min: "minute",
  mins: "minute",
  minute: "minute",
  minutes: "minute",
  h: "hour",
  hr: "hour",
  hrs: "hour",
  hour: "hour",
  hours: "hour",
  d: "d",
  day: "d",
  days: "d",
  w: "w",
  week: "week",
  weeks: "week",
  mo: "month",
  mon: "month",
  mos: "month",
  month: "month",
  months: "month",
  qtr: "quarter",
  quarter: "quarter",
  quarters: "quarter",
  y: "year",
  yr: "year",
  year: "year",
  years: "year",
  ...TIME_UNIT_DICTIONARY_NO_ABBR
};
var NUMBER_PATTERN = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|the|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
function parseNumberPattern(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY[num];
  } else if (num === "a" || num === "an" || num == "the") {
    return 1;
  } else if (num.match(/few/)) {
    return 3;
  } else if (num.match(/half/)) {
    return 0.5;
  } else if (num.match(/couple/)) {
    return 2;
  } else if (num.match(/several/)) {
    return 7;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
function parseOrdinalNumberPattern(match) {
  let num = match.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY[num];
  }
  num = num.replace(/(?:st|nd|rd|th)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9]|2[0-5])`;
function parseYear(match) {
  if (/BE/i.test(match)) {
    match = match.replace(/BE/i, "");
    return parseInt(match) - 543;
  }
  if (/BCE?/i.test(match)) {
    match = match.replace(/BCE?/i, "");
    return -parseInt(match);
  }
  if (/(AD|CE)/i.test(match)) {
    match = match.replace(/(AD|CE)/i, "");
    return parseInt(match);
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;
var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
var SINGLE_TIME_UNIT_NO_ABBR_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY_NO_ABBR)})`;
var TIME_UNIT_CONNECTOR_PATTERN = `\\s{0,5},?(?:\\s*and)?\\s{0,5}`;
var TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
var TIME_UNITS_NO_ABBR_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_NO_ABBR_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
function parseTimeUnits(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
  while (match) {
    collectDateTimeFragment(fragments, match);
    remainingText = remainingText.substring(match[0].length).trim();
    match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
  }
  if (Object.keys(fragments).length == 0) {
    return null;
  }
  return fragments;
}
function collectDateTimeFragment(fragments, match) {
  if (match[0].match(/^[a-zA-Z]+$/)) {
    return;
  }
  const num = parseNumberPattern(match[1]);
  const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/common/parsers/AbstractParserWithWordBoundary.js
var AbstractParserWithWordBoundaryChecking = class {
  innerPatternHasChange(context, currentInnerPattern) {
    return this.innerPattern(context) !== currentInnerPattern;
  }
  patternLeftBoundary() {
    return `(\\W|^)`;
  }
  cachedInnerPattern = null;
  cachedPattern = null;
  pattern(context) {
    if (this.cachedInnerPattern) {
      if (!this.innerPatternHasChange(context, this.cachedInnerPattern)) {
        return this.cachedPattern;
      }
    }
    this.cachedInnerPattern = this.innerPattern(context);
    this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${this.cachedInnerPattern.source}`, this.cachedInnerPattern.flags);
    return this.cachedPattern;
  }
  extract(context, match) {
    const header = match[1] ?? "";
    match.index = match.index + header.length;
    match[0] = match[0].substring(header.length);
    for (let i = 2; i < match.length; i++) {
      match[i - 1] = match[i];
    }
    return this.innerExtract(context, match);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitWithinFormatParser.js
var PATTERN_WITH_OPTIONAL_PREFIX = new RegExp(`(?:(?:within|in|for)\\s*)?(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
var PATTERN_WITH_PREFIX_STRICT = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  strictMode;
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern(context) {
    if (this.strictMode) {
      return PATTERN_WITH_PREFIX_STRICT;
    }
    return context.option.forwardDate ? PATTERN_WITH_OPTIONAL_PREFIX : PATTERN_WITH_PREFIX;
  }
  innerExtract(context, match) {
    if (match[0].match(/^for\s*the\s*\w+/)) {
      return null;
    }
    const timeUnits = parseTimeUnits(match[1]);
    if (!timeUnits) {
      return null;
    }
    context.debug(() => {
      console.log(timeUnits);
      console.log(ParsingComponents.createRelativeFromReference(context.reference, timeUnits));
    });
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameLittleEndianParser.js
var PATTERN = new RegExp(`(?:on\\s{0,3})?(${ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\â€“|until|through|till)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${YEAR_PATTERN}(?!\\w)))?(?=\\W|$)`, "i");
var DATE_GROUP = 1;
var DATE_TO_GROUP = 2;
var MONTH_NAME_GROUP = 3;
var YEAR_GROUP = 4;
var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
    const day = parseOrdinalNumberPattern(match[DATE_GROUP]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP]) {
      const yearNumber = parseYear(match[YEAR_GROUP]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP]) {
      const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameMiddleEndianParser.js
var PATTERN2 = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,\\s*|\\s+)(${YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
var MONTH_NAME_GROUP2 = 1;
var DATE_GROUP2 = 2;
var DATE_TO_GROUP2 = 3;
var YEAR_GROUP2 = 4;
var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  shouldSkipYearLikeDate;
  constructor(shouldSkipYearLikeDate) {
    super();
    this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;
  }
  innerPattern() {
    return PATTERN2;
  }
  innerExtract(context, match) {
    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP2].toLowerCase()];
    const day = parseOrdinalNumberPattern(match[DATE_GROUP2]);
    if (day > 31) {
      return null;
    }
    if (this.shouldSkipYearLikeDate) {
      if (!match[DATE_TO_GROUP2] && !match[YEAR_GROUP2] && match[DATE_GROUP2].match(/^2[0-5]$/)) {
        return null;
      }
    }
    const components = context.createParsingComponents({
      day,
      month
    }).addTag("parser/ENMonthNameMiddleEndianParser");
    if (match[YEAR_GROUP2]) {
      const year3 = parseYear(match[YEAR_GROUP2]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      components.imply("year", year3);
    }
    if (!match[DATE_TO_GROUP2]) {
      return components;
    }
    const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP2]);
    const result = context.createParsingResult(match.index, match[0]);
    result.start = components;
    result.end = components.clone();
    result.end.assign("day", endDate);
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameParser.js
var PATTERN3 = new RegExp(`((?:in)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY)})\\s*(?:(?:,|-|of)?\\s*(${YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
var PREFIX_GROUP = 1;
var MONTH_NAME_GROUP3 = 2;
var YEAR_GROUP3 = 3;
var ENMonthNameParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN3;
  }
  innerExtract(context, match) {
    const monthName = match[MONTH_NAME_GROUP3].toLowerCase();
    if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match.index + (match[PREFIX_GROUP] || "").length, match.index + match[0].length);
    result.start.imply("day", 1);
    result.start.addTag("parser/ENMonthNameParser");
    const month = MONTH_DICTIONARY[monthName];
    result.start.assign("month", month);
    if (match[YEAR_GROUP3]) {
      const year3 = parseYear(match[YEAR_GROUP3]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENYearMonthDayParser.js
var PATTERN4 = new RegExp(`([0-9]{4})[-\\.\\/\\s](?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[-\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
var YEAR_NUMBER_GROUP = 1;
var MONTH_NAME_GROUP4 = 2;
var MONTH_NUMBER_GROUP = 3;
var DATE_NUMBER_GROUP = 4;
var ENYearMonthDayParser = class extends AbstractParserWithWordBoundaryChecking {
  strictMonthDateOrder;
  constructor(strictMonthDateOrder) {
    super();
    this.strictMonthDateOrder = strictMonthDateOrder;
  }
  innerPattern() {
    return PATTERN4;
  }
  innerExtract(context, match) {
    const year3 = parseInt(match[YEAR_NUMBER_GROUP]);
    let day = parseInt(match[DATE_NUMBER_GROUP]);
    let month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : MONTH_DICTIONARY[match[MONTH_NAME_GROUP4].toLowerCase()];
    if (month < 1 || month > 12) {
      if (this.strictMonthDateOrder) {
        return null;
      }
      if (day >= 1 && day <= 12) {
        [month, day] = [day, month];
      }
    }
    if (day < 1 || day > 31) {
      return null;
    }
    return {
      day,
      month,
      year: year3
    };
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENSlashMonthFormatParser.js
var PATTERN5 = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
var MONTH_GROUP = 1;
var YEAR_GROUP4 = 2;
var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN5;
  }
  innerExtract(context, match) {
    const year3 = parseInt(match[YEAR_GROUP4]);
    const month = parseInt(match[MONTH_GROUP]);
    return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year3);
  }
};

// node_modules/chrono-node/dist/esm/common/parsers/AbstractTimeExpressionParser.js
function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
  return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|ï¼š)(\\d{1,2})(?:(?::|ï¼š)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
}
function followingTimePatten(followingPhase, followingSuffix) {
  return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\ï¼š)(\\d{1,2})(?:(?:\\.|\\:|\\ï¼š)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
}
var HOUR_GROUP = 2;
var MINUTE_GROUP = 3;
var SECOND_GROUP = 4;
var MILLI_SECOND_GROUP = 5;
var AM_PM_HOUR_GROUP = 6;
var AbstractTimeExpressionParser = class {
  strictMode;
  constructor(strictMode = false) {
    this.strictMode = strictMode;
  }
  patternFlags() {
    return "i";
  }
  primaryPatternLeftBoundary() {
    return `(^|\\s|T|\\b)`;
  }
  primarySuffix() {
    return `(?!/)(?=\\W|$)`;
  }
  followingSuffix() {
    return `(?!/)(?=\\W|$)`;
  }
  pattern(context) {
    return this.getPrimaryTimePatternThroughCache();
  }
  extract(context, match) {
    const startComponents = this.extractPrimaryTimeComponents(context, match);
    if (!startComponents) {
      if (match[0].match(/^\d{4}/)) {
        match.index += 4;
        return null;
      }
      match.index += match[0].length;
      return null;
    }
    const index = match.index + match[1].length;
    const text = match[0].substring(match[1].length);
    const result = context.createParsingResult(index, text, startComponents);
    match.index += match[0].length;
    const remainingText = context.text.substring(match.index);
    const followingPattern = this.getFollowingTimePatternThroughCache();
    const followingMatch = followingPattern.exec(remainingText);
    if (text.match(/^\d{3,4}/) && followingMatch) {
      if (followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
        return null;
      }
      if (followingMatch[0].match(/^\s*([+-])\s*\d{2}\W\d{2}/)) {
        return null;
      }
    }
    if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
      return this.checkAndReturnWithoutFollowingPattern(result);
    }
    result.end = this.extractFollowingTimeComponents(context, followingMatch, result);
    if (result.end) {
      result.text += followingMatch[0];
    }
    return this.checkAndReturnWithFollowingPattern(result);
  }
  extractPrimaryTimeComponents(context, match, strict14 = false) {
    const components = context.createParsingComponents();
    let minute = 0;
    let meridiem = null;
    let hour = parseInt(match[HOUR_GROUP]);
    if (hour > 100) {
      if (this.strictMode || match[MINUTE_GROUP] != null) {
        return null;
      }
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (hour > 24) {
      return null;
    }
    if (match[MINUTE_GROUP] != null) {
      if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {
        return null;
      }
      minute = parseInt(match[MINUTE_GROUP]);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP] != null) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
      if (ampm == "a") {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
        }
      }
      if (ampm == "p") {
        meridiem = Meridiem.PM;
        if (hour != 12) {
          hour += 12;
        }
      }
    }
    components.assign("hour", hour);
    components.assign("minute", minute);
    if (meridiem !== null) {
      components.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        components.imply("meridiem", Meridiem.AM);
      } else {
        components.imply("meridiem", Meridiem.PM);
      }
    }
    if (match[MILLI_SECOND_GROUP] != null) {
      const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
      if (millisecond >= 1e3)
        return null;
      components.assign("millisecond", millisecond);
    }
    if (match[SECOND_GROUP] != null) {
      const second = parseInt(match[SECOND_GROUP]);
      if (second >= 60)
        return null;
      components.assign("second", second);
    }
    return components;
  }
  extractFollowingTimeComponents(context, match, result) {
    const components = context.createParsingComponents();
    if (match[MILLI_SECOND_GROUP] != null) {
      const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
      if (millisecond >= 1e3)
        return null;
      components.assign("millisecond", millisecond);
    }
    if (match[SECOND_GROUP] != null) {
      const second = parseInt(match[SECOND_GROUP]);
      if (second >= 60)
        return null;
      components.assign("second", second);
    }
    let hour = parseInt(match[HOUR_GROUP]);
    let minute = 0;
    let meridiem = -1;
    if (match[MINUTE_GROUP] != null) {
      minute = parseInt(match[MINUTE_GROUP]);
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60 || hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP] != null) {
      if (hour > 12) {
        return null;
      }
      const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
      if (ampm == "a") {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
          if (!components.isCertain("day")) {
            components.imply("day", components.get("day") + 1);
          }
        }
      }
      if (ampm == "p") {
        meridiem = Meridiem.PM;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem == Meridiem.AM) {
          result.start.imply("meridiem", Meridiem.AM);
          if (result.start.get("hour") == 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", Meridiem.PM);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    }
    components.assign("hour", hour);
    components.assign("minute", minute);
    if (meridiem >= 0) {
      components.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
      if (startAtPM) {
        if (result.start.get("hour") - 12 > hour) {
          components.imply("meridiem", Meridiem.AM);
        } else if (hour <= 12) {
          components.assign("hour", hour + 12);
          components.assign("meridiem", Meridiem.PM);
        }
      } else if (hour > 12) {
        components.imply("meridiem", Meridiem.PM);
      } else if (hour <= 12) {
        components.imply("meridiem", Meridiem.AM);
      }
    }
    if (components.date().getTime() < result.start.date().getTime()) {
      components.imply("day", components.get("day") + 1);
    }
    return components;
  }
  checkAndReturnWithoutFollowingPattern(result) {
    if (result.text.match(/^\d$/)) {
      return null;
    }
    if (result.text.match(/^\d\d\d+$/)) {
      return null;
    }
    if (result.text.match(/\d[apAP]$/)) {
      return null;
    }
    const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
    if (endingWithNumbers) {
      const endingNumbers = endingWithNumbers[1];
      if (this.strictMode) {
        return null;
      }
      if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
        return null;
      }
      const endingNumberVal = parseInt(endingNumbers);
      if (endingNumberVal > 24) {
        return null;
      }
    }
    return result;
  }
  checkAndReturnWithFollowingPattern(result) {
    if (result.text.match(/^\d+-\d+$/)) {
      return null;
    }
    const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
    if (endingWithNumbers) {
      if (this.strictMode) {
        return null;
      }
      const startingNumbers = endingWithNumbers[1];
      const endingNumbers = endingWithNumbers[2];
      if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
        return null;
      }
      const endingNumberVal = parseInt(endingNumbers);
      const startingNumberVal = parseInt(startingNumbers);
      if (endingNumberVal > 24 || startingNumberVal > 24) {
        return null;
      }
    }
    return result;
  }
  cachedPrimaryPrefix = null;
  cachedPrimarySuffix = null;
  cachedPrimaryTimePattern = null;
  getPrimaryTimePatternThroughCache() {
    const primaryPrefix = this.primaryPrefix();
    const primarySuffix = this.primarySuffix();
    if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
      return this.cachedPrimaryTimePattern;
    }
    this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
    this.cachedPrimaryPrefix = primaryPrefix;
    this.cachedPrimarySuffix = primarySuffix;
    return this.cachedPrimaryTimePattern;
  }
  cachedFollowingPhase = null;
  cachedFollowingSuffix = null;
  cachedFollowingTimePatten = null;
  getFollowingTimePatternThroughCache() {
    const followingPhase = this.followingPhase();
    const followingSuffix = this.followingSuffix();
    if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
      return this.cachedFollowingTimePatten;
    }
    this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
    this.cachedFollowingPhase = followingPhase;
    this.cachedFollowingSuffix = followingSuffix;
    return this.cachedFollowingTimePatten;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeExpressionParser.js
var ENTimeExpressionParser = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  followingPhase() {
    return "\\s*(?:\\-|\\â€“|\\~|\\ã€œ|to|until|through|till|\\?)\\s*";
  }
  primaryPrefix() {
    return "(?:(?:at|from)\\s*)??";
  }
  primarySuffix() {
    return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
  }
  extractPrimaryTimeComponents(context, match) {
    const components = super.extractPrimaryTimeComponents(context, match);
    if (!components) {
      return components;
    }
    if (match[0].endsWith("night")) {
      const hour = components.get("hour");
      if (hour >= 6 && hour < 12) {
        components.assign("hour", components.get("hour") + 12);
        components.assign("meridiem", Meridiem.PM);
      } else if (hour < 6) {
        components.assign("meridiem", Meridiem.AM);
      }
    }
    if (match[0].endsWith("afternoon")) {
      components.assign("meridiem", Meridiem.PM);
      const hour = components.get("hour");
      if (hour >= 0 && hour <= 6) {
        components.assign("hour", components.get("hour") + 12);
      }
    }
    if (match[0].endsWith("morning")) {
      components.assign("meridiem", Meridiem.AM);
      const hour = components.get("hour");
      if (hour < 12) {
        components.assign("hour", components.get("hour"));
      }
    }
    return components.addTag("parser/ENTimeExpressionParser");
  }
  extractFollowingTimeComponents(context, match, result) {
    const followingComponents = super.extractFollowingTimeComponents(context, match, result);
    if (followingComponents) {
      followingComponents.addTag("parser/ENTimeExpressionParser");
    }
    return followingComponents;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitAgoFormatParser.js
var PATTERN6 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
var STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  strictMode;
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN : PATTERN6;
  }
  innerExtract(context, match) {
    const duration = parseTimeUnits(match[1]);
    if (!duration) {
      return null;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, reverseDuration(duration));
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitLaterFormatParser.js
var PATTERN7 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
var STRICT_PATTERN2 = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(later|after|from now)(?=\\W|$)`, "i");
var GROUP_NUM_TIMEUNITS = 1;
var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  strictMode;
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN2 : PATTERN7;
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
    if (!timeUnits) {
      return null;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/common/abstractRefiners.js
var Filter = class {
  refine(context, results) {
    return results.filter((r) => this.isValid(context, r));
  }
};
var MergingRefiner = class {
  refine(context, results) {
    if (results.length < 2) {
      return results;
    }
    const mergedResults = [];
    let curResult = results[0];
    let nextResult = null;
    for (let i = 1; i < results.length; i++) {
      nextResult = results[i];
      const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
      if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
        mergedResults.push(curResult);
        curResult = nextResult;
      } else {
        const left = curResult;
        const right = nextResult;
        const mergedResult = this.mergeResults(textBetween, left, right, context);
        context.debug(() => {
          console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);
        });
        curResult = mergedResult;
      }
    }
    if (curResult != null) {
      mergedResults.push(curResult);
    }
    return mergedResults;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateRangeRefiner.js
var AbstractMergeDateRangeRefiner = class extends MergingRefiner {
  shouldMergeResults(textBetween, currentResult, nextResult) {
    return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
  }
  mergeResults(textBetween, fromResult, toResult) {
    if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
      toResult.start.getCertainComponents().forEach((key) => {
        if (!fromResult.start.isCertain(key)) {
          fromResult.start.imply(key, toResult.start.get(key));
        }
      });
      fromResult.start.getCertainComponents().forEach((key) => {
        if (!toResult.start.isCertain(key)) {
          toResult.start.imply(key, fromResult.start.get(key));
        }
      });
    }
    if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
      let fromMoment = fromResult.start.dayjs();
      let toMoment = toResult.start.dayjs();
      if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
        toMoment = toMoment.add(7, "days");
        toResult.start.imply("day", toMoment.date());
        toResult.start.imply("month", toMoment.month() + 1);
        toResult.start.imply("year", toMoment.year());
      } else if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
        fromMoment = fromMoment.add(-7, "days");
        fromResult.start.imply("day", fromMoment.date());
        fromResult.start.imply("month", fromMoment.month() + 1);
        fromResult.start.imply("year", fromMoment.year());
      } else if (toResult.start.isDateWithUnknownYear() && toMoment.add(1, "years").isAfter(fromMoment)) {
        toMoment = toMoment.add(1, "years");
        toResult.start.imply("year", toMoment.year());
      } else if (fromResult.start.isDateWithUnknownYear() && fromMoment.add(-1, "years").isBefore(toMoment)) {
        fromMoment = fromMoment.add(-1, "years");
        fromResult.start.imply("year", fromMoment.year());
      } else {
        [toResult, fromResult] = [fromResult, toResult];
      }
    }
    const result = fromResult.clone();
    result.start = fromResult.start;
    result.end = toResult.start;
    result.index = Math.min(fromResult.index, toResult.index);
    if (fromResult.index < toResult.index) {
      result.text = fromResult.text + textBetween + toResult.text;
    } else {
      result.text = toResult.text + textBetween + fromResult.text;
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateRangeRefiner.js
var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(to|-|â€“|until|through|till)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/utils/dayjs.js
function assignTheNextDay(component, targetDayJs) {
  targetDayJs = targetDayJs.add(1, "day");
  assignSimilarDate2(component, targetDayJs);
  implySimilarTime2(component, targetDayJs);
}
function implyTheNextDay(component, targetDayJs) {
  targetDayJs = targetDayJs.add(1, "day");
  implySimilarDate2(component, targetDayJs);
  implySimilarTime2(component, targetDayJs);
}
function assignSimilarDate2(component, targetDayJs) {
  component.assign("day", targetDayJs.date());
  component.assign("month", targetDayJs.month() + 1);
  component.assign("year", targetDayJs.year());
}
function assignSimilarTime2(component, targetDayJs) {
  component.assign("hour", targetDayJs.hour());
  component.assign("minute", targetDayJs.minute());
  component.assign("second", targetDayJs.second());
  component.assign("millisecond", targetDayJs.millisecond());
  if (component.get("hour") < 12) {
    component.assign("meridiem", Meridiem.AM);
  } else {
    component.assign("meridiem", Meridiem.PM);
  }
}
function implySimilarDate2(component, targetDayJs) {
  component.imply("day", targetDayJs.date());
  component.imply("month", targetDayJs.month() + 1);
  component.imply("year", targetDayJs.year());
}
function implySimilarTime2(component, targetDayJs) {
  component.imply("hour", targetDayJs.hour());
  component.imply("minute", targetDayJs.minute());
  component.imply("second", targetDayJs.second());
  component.imply("millisecond", targetDayJs.millisecond());
}

// node_modules/chrono-node/dist/esm/calculation/mergingCalculation.js
function mergeDateTimeResult(dateResult, timeResult) {
  const result = dateResult.clone();
  const beginDate = dateResult.start;
  const beginTime = timeResult.start;
  result.start = mergeDateTimeComponent(beginDate, beginTime);
  if (dateResult.end != null || timeResult.end != null) {
    const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
    const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
    const endDateTime = mergeDateTimeComponent(endDate, endTime);
    if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
      const nextDayJs = endDateTime.dayjs().add(1, "day");
      if (endDateTime.isCertain("day")) {
        assignSimilarDate2(endDateTime, nextDayJs);
      } else {
        implySimilarDate2(endDateTime, nextDayJs);
      }
    }
    result.end = endDateTime;
  }
  return result;
}
function mergeDateTimeComponent(dateComponent, timeComponent) {
  const dateTimeComponent = dateComponent.clone();
  if (timeComponent.isCertain("hour")) {
    dateTimeComponent.assign("hour", timeComponent.get("hour"));
    dateTimeComponent.assign("minute", timeComponent.get("minute"));
    if (timeComponent.isCertain("second")) {
      dateTimeComponent.assign("second", timeComponent.get("second"));
      if (timeComponent.isCertain("millisecond")) {
        dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
      } else {
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
    } else {
      dateTimeComponent.imply("second", timeComponent.get("second"));
      dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
    }
  } else {
    dateTimeComponent.imply("hour", timeComponent.get("hour"));
    dateTimeComponent.imply("minute", timeComponent.get("minute"));
    dateTimeComponent.imply("second", timeComponent.get("second"));
    dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
  }
  if (timeComponent.isCertain("timezoneOffset")) {
    dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
  }
  if (timeComponent.isCertain("meridiem")) {
    dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
  } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
    dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
  }
  if (dateTimeComponent.get("meridiem") == Meridiem.PM && dateTimeComponent.get("hour") < 12) {
    if (timeComponent.isCertain("hour")) {
      dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
    } else {
      dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
    }
  }
  dateTimeComponent.addTags(dateComponent.tags());
  dateTimeComponent.addTags(timeComponent.tags());
  return dateTimeComponent;
}

// node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateTimeRefiner.js
var AbstractMergeDateTimeRefiner = class extends MergingRefiner {
  shouldMergeResults(textBetween, currentResult, nextResult) {
    return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
  }
  mergeResults(textBetween, currentResult, nextResult) {
    const result = currentResult.start.isOnlyDate() ? mergeDateTimeResult(currentResult, nextResult) : mergeDateTimeResult(nextResult, currentResult);
    result.index = currentResult.index;
    result.text = currentResult.text + textBetween + nextResult.text;
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateTimeRefiner.js
var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|at|after|before|on|of|,|-|\\.|âˆ™|:)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneAbbrRefiner.js
var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
var ExtractTimezoneAbbrRefiner = class {
  timezoneOverrides;
  constructor(timezoneOverrides) {
    this.timezoneOverrides = timezoneOverrides;
  }
  refine(context, results) {
    const timezoneOverrides = context.option.timezones ?? {};
    results.forEach((result) => {
      const suffix = context.text.substring(result.index + result.text.length);
      const match = TIMEZONE_NAME_PATTERN.exec(suffix);
      if (!match) {
        return;
      }
      const timezoneAbbr = match[1].toUpperCase();
      const refDate = result.start.date() ?? result.refDate ?? /* @__PURE__ */ new Date();
      const tzOverrides = { ...this.timezoneOverrides, ...timezoneOverrides };
      const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);
      if (extractedTimezoneOffset == null) {
        return;
      }
      context.debug(() => {
        console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
      });
      const currentTimezoneOffset = result.start.get("timezoneOffset");
      if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
        if (result.start.isCertain("timezoneOffset")) {
          return;
        }
        if (timezoneAbbr != match[1]) {
          return;
        }
      }
      if (result.start.isOnlyDate()) {
        if (timezoneAbbr != match[1]) {
          return;
        }
      }
      result.text += match[0];
      if (!result.start.isCertain("timezoneOffset")) {
        result.start.assign("timezoneOffset", extractedTimezoneOffset);
      }
      if (result.end != null && !result.end.isCertain("timezoneOffset")) {
        result.end.assign("timezoneOffset", extractedTimezoneOffset);
      }
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneOffsetRefiner.js
var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
var TIMEZONE_OFFSET_SIGN_GROUP = 1;
var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
var ExtractTimezoneOffsetRefiner = class {
  refine(context, results) {
    results.forEach(function(result) {
      if (result.start.isCertain("timezoneOffset")) {
        return;
      }
      const suffix = context.text.substring(result.index + result.text.length);
      const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);
      if (!match) {
        return;
      }
      context.debug(() => {
        console.log(`Extracting timezone: '${match[0]}' into : ${result}`);
      });
      const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
      const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
      let timezoneOffset = hourOffset * 60 + minuteOffset;
      if (timezoneOffset > 14 * 60) {
        return;
      }
      if (match[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
        timezoneOffset = -timezoneOffset;
      }
      if (result.end != null) {
        result.end.assign("timezoneOffset", timezoneOffset);
      }
      result.start.assign("timezoneOffset", timezoneOffset);
      result.text += match[0];
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/OverlapRemovalRefiner.js
var OverlapRemovalRefiner = class {
  refine(context, results) {
    if (results.length < 2) {
      return results;
    }
    const filteredResults = [];
    let prevResult = results[0];
    for (let i = 1; i < results.length; i++) {
      const result = results[i];
      if (result.index >= prevResult.index + prevResult.text.length) {
        filteredResults.push(prevResult);
        prevResult = result;
        continue;
      }
      let kept = null;
      let removed = null;
      if (result.text.length > prevResult.text.length) {
        kept = result;
        removed = prevResult;
      } else {
        kept = prevResult;
        removed = result;
      }
      context.debug(() => {
        console.log(`${this.constructor.name} remove ${removed} by ${kept}`);
      });
      prevResult = kept;
    }
    if (prevResult != null) {
      filteredResults.push(prevResult);
    }
    return filteredResults;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/ForwardDateRefiner.js
var import_dayjs5 = __toESM(require_dayjs_min(), 1);
var ForwardDateRefiner = class {
  refine(context, results) {
    if (!context.option.forwardDate) {
      return results;
    }
    results.forEach((result) => {
      let refMoment = (0, import_dayjs5.default)(context.reference.getDateWithAdjustedTimezone());
      if (result.start.isOnlyTime() && context.reference.instant > result.start.date()) {
        const refDate = context.reference.getDateWithAdjustedTimezone();
        const refFollowingDay = new Date(refDate);
        refFollowingDay.setDate(refFollowingDay.getDate() + 1);
        implySimilarDate(result.start, refFollowingDay);
        context.debug(() => {
          console.log(`${this.constructor.name} adjusted ${result} time from the ref date (${refDate}) to the following day (${refFollowingDay})`);
        });
        if (result.end && result.end.isOnlyTime()) {
          implySimilarDate(result.end, refFollowingDay);
          if (result.start.date() > result.end.date()) {
            refFollowingDay.setDate(refFollowingDay.getDate() + 1);
            implySimilarDate(result.end, refFollowingDay);
          }
        }
      }
      if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {
        if (refMoment.day() >= result.start.get("weekday")) {
          refMoment = refMoment.day(result.start.get("weekday") + 7);
        } else {
          refMoment = refMoment.day(result.start.get("weekday"));
        }
        result.start.imply("day", refMoment.date());
        result.start.imply("month", refMoment.month() + 1);
        result.start.imply("year", refMoment.year());
        context.debug(() => {
          console.log(`${this.constructor.name} adjusted ${result} weekday (${result.start})`);
        });
        if (result.end && result.end.isOnlyWeekdayComponent()) {
          if (refMoment.day() > result.end.get("weekday")) {
            refMoment = refMoment.day(result.end.get("weekday") + 7);
          } else {
            refMoment = refMoment.day(result.end.get("weekday"));
          }
          result.end.imply("day", refMoment.date());
          result.end.imply("month", refMoment.month() + 1);
          result.end.imply("year", refMoment.year());
          context.debug(() => {
            console.log(`${this.constructor.name} adjusted ${result} weekday (${result.end})`);
          });
        }
      }
      if (result.start.isDateWithUnknownYear() && refMoment.isAfter(result.start.dayjs())) {
        for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {
          result.start.imply("year", result.start.get("year") + 1);
          context.debug(() => {
            console.log(`${this.constructor.name} adjusted ${result} year (${result.start})`);
          });
          if (result.end && !result.end.isCertain("year")) {
            result.end.imply("year", result.end.get("year") + 1);
            context.debug(() => {
              console.log(`${this.constructor.name} adjusted ${result} month (${result.start})`);
            });
          }
        }
      }
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/UnlikelyFormatFilter.js
var UnlikelyFormatFilter = class extends Filter {
  strictMode;
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  isValid(context, result) {
    if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
      context.debug(() => {
        console.log(`Removing unlikely result '${result.text}'`);
      });
      return false;
    }
    if (!result.start.isValidDate()) {
      context.debug(() => {
        console.log(`Removing invalid result: ${result} (${result.start})`);
      });
      return false;
    }
    if (result.end && !result.end.isValidDate()) {
      context.debug(() => {
        console.log(`Removing invalid result: ${result} (${result.end})`);
      });
      return false;
    }
    if (this.strictMode) {
      return this.isStrictModeValid(context, result);
    }
    return true;
  }
  isStrictModeValid(context, result) {
    if (result.start.isOnlyWeekdayComponent()) {
      context.debug(() => {
        console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
      });
      return false;
    }
    return true;
  }
};

// node_modules/chrono-node/dist/esm/common/parsers/ISOFormatParser.js
var PATTERN8 = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
var YEAR_NUMBER_GROUP2 = 1;
var MONTH_NUMBER_GROUP2 = 2;
var DATE_NUMBER_GROUP2 = 3;
var HOUR_NUMBER_GROUP = 4;
var MINUTE_NUMBER_GROUP = 5;
var SECOND_NUMBER_GROUP = 6;
var MILLISECOND_NUMBER_GROUP = 7;
var TZD_GROUP = 8;
var TZD_HOUR_OFFSET_GROUP = 9;
var TZD_MINUTE_OFFSET_GROUP = 10;
var ISOFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN8;
  }
  innerExtract(context, match) {
    const components = context.createParsingComponents({
      "year": parseInt(match[YEAR_NUMBER_GROUP2]),
      "month": parseInt(match[MONTH_NUMBER_GROUP2]),
      "day": parseInt(match[DATE_NUMBER_GROUP2])
    });
    if (match[HOUR_NUMBER_GROUP] != null) {
      components.assign("hour", parseInt(match[HOUR_NUMBER_GROUP]));
      components.assign("minute", parseInt(match[MINUTE_NUMBER_GROUP]));
      if (match[SECOND_NUMBER_GROUP] != null) {
        components.assign("second", parseInt(match[SECOND_NUMBER_GROUP]));
      }
      if (match[MILLISECOND_NUMBER_GROUP] != null) {
        components.assign("millisecond", parseInt(match[MILLISECOND_NUMBER_GROUP]));
      }
      if (match[TZD_GROUP] != null) {
        let offset = 0;
        if (match[TZD_HOUR_OFFSET_GROUP]) {
          const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);
          let minuteOffset = 0;
          if (match[TZD_MINUTE_OFFSET_GROUP] != null) {
            minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);
          }
          offset = hourOffset * 60;
          if (offset < 0) {
            offset -= minuteOffset;
          } else {
            offset += minuteOffset;
          }
        }
        components.assign("timezoneOffset", offset);
      }
    }
    return components.addTag("parser/ISOFormatParser");
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/MergeWeekdayComponentRefiner.js
var MergeWeekdayComponentRefiner = class extends MergingRefiner {
  mergeResults(textBetween, currentResult, nextResult) {
    const newResult = nextResult.clone();
    newResult.index = currentResult.index;
    newResult.text = currentResult.text + textBetween + newResult.text;
    newResult.start.assign("weekday", currentResult.start.get("weekday"));
    if (newResult.end) {
      newResult.end.assign("weekday", currentResult.start.get("weekday"));
    }
    return newResult;
  }
  shouldMergeResults(textBetween, currentResult, nextResult) {
    const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
    return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
  }
};

// node_modules/chrono-node/dist/esm/configurations.js
function includeCommonConfiguration(configuration2, strictMode = false) {
  configuration2.parsers.unshift(new ISOFormatParser());
  configuration2.refiners.unshift(new MergeWeekdayComponentRefiner());
  configuration2.refiners.unshift(new ExtractTimezoneOffsetRefiner());
  configuration2.refiners.unshift(new OverlapRemovalRefiner());
  configuration2.refiners.push(new ExtractTimezoneAbbrRefiner());
  configuration2.refiners.push(new OverlapRemovalRefiner());
  configuration2.refiners.push(new ForwardDateRefiner());
  configuration2.refiners.push(new UnlikelyFormatFilter(strictMode));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualDateParser.js
var import_dayjs8 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/common/casualReferences.js
var import_dayjs6 = __toESM(require_dayjs_min(), 1);
function now(reference) {
  const targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
  const component = new ParsingComponents(reference, {});
  assignSimilarDate2(component, targetDate);
  assignSimilarTime2(component, targetDate);
  component.assign("timezoneOffset", reference.getTimezoneOffset());
  component.addTag("casualReference/now");
  return component;
}
function today(reference) {
  const targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
  const component = new ParsingComponents(reference, {});
  assignSimilarDate2(component, targetDate);
  implySimilarTime2(component, targetDate);
  component.addTag("casualReference/today");
  return component;
}
function yesterday(reference) {
  return theDayBefore(reference, 1).addTag("casualReference/yesterday");
}
function theDayBefore(reference, numDay) {
  return theDayAfter(reference, -numDay);
}
function tomorrow(reference) {
  return theDayAfter(reference, 1).addTag("casualReference/tomorrow");
}
function theDayAfter(reference, nDays) {
  let targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
  const component = new ParsingComponents(reference, {});
  targetDate = targetDate.add(nDays, "day");
  assignSimilarDate2(component, targetDate);
  implySimilarTime2(component, targetDate);
  return component;
}
function tonight(reference, implyHour = 22) {
  const targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
  const component = new ParsingComponents(reference, {});
  assignSimilarDate2(component, targetDate);
  component.imply("hour", implyHour);
  component.imply("meridiem", Meridiem.PM);
  component.addTag("casualReference/tonight");
  return component;
}
function lastNight(reference, implyHour = 0) {
  let targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
  const component = new ParsingComponents(reference, {});
  if (targetDate.hour() < 6) {
    targetDate = targetDate.add(-1, "day");
  }
  assignSimilarDate2(component, targetDate);
  component.imply("hour", implyHour);
  return component;
}
function evening(reference, implyHour = 20) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.PM);
  component.imply("hour", implyHour);
  component.addTag("casualReference/evening");
  return component;
}
function yesterdayEvening(reference, implyHour = 20) {
  let targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
  const component = new ParsingComponents(reference, {});
  targetDate = targetDate.add(-1, "day");
  assignSimilarDate2(component, targetDate);
  component.imply("hour", implyHour);
  component.imply("meridiem", Meridiem.PM);
  component.addTag("casualReference/yesterday");
  component.addTag("casualReference/evening");
  return component;
}
function midnight(reference) {
  const component = new ParsingComponents(reference, {});
  const targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
  if (targetDate.hour() > 2) {
    implyTheNextDay(component, targetDate);
  }
  component.assign("hour", 0);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/midnight");
  return component;
}
function morning(reference, implyHour = 6) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.AM);
  component.imply("hour", implyHour);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/morning");
  return component;
}
function afternoon(reference, implyHour = 15) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.PM);
  component.imply("hour", implyHour);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/afternoon");
  return component;
}
function noon(reference) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.AM);
  component.assign("hour", 12);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/noon");
  return component;
}

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualDateParser.js
var PATTERN9 = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
var ENCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return PATTERN9;
  }
  innerExtract(context, match) {
    let targetDate = (0, import_dayjs8.default)(context.refDate);
    const lowerText = match[0].toLowerCase();
    let component = context.createParsingComponents();
    switch (lowerText) {
      case "now":
        component = now(context.reference);
        break;
      case "today":
        component = today(context.reference);
        break;
      case "yesterday":
        component = yesterday(context.reference);
        break;
      case "tomorrow":
      case "tmr":
      case "tmrw":
        component = tomorrow(context.reference);
        break;
      case "tonight":
        component = tonight(context.reference);
        break;
      case "overmorrow":
        component = theDayAfter(context.reference, 2);
        break;
      default:
        if (lowerText.match(/last\s*night/)) {
          if (targetDate.hour() > 6) {
            targetDate = targetDate.add(-1, "day");
          }
          assignSimilarDate2(component, targetDate);
          component.imply("hour", 0);
        }
        break;
    }
    component.addTag("parser/ENCasualDateParser");
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualTimeParser.js
var PATTERN10 = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|midday|noon)(?=\W|$)/i;
var ENCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN10;
  }
  innerExtract(context, match) {
    let component = null;
    switch (match[1].toLowerCase()) {
      case "afternoon":
        component = afternoon(context.reference);
        break;
      case "evening":
      case "night":
        component = evening(context.reference);
        break;
      case "midnight":
        component = midnight(context.reference);
        break;
      case "morning":
        component = morning(context.reference);
        break;
      case "noon":
      case "midday":
        component = noon(context.reference);
        break;
    }
    if (component) {
      component.addTag("parser/ENCasualTimeParser");
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/utils/timeunits.js
function reverseTimeUnits(timeUnits) {
  const reversed = {};
  for (const key in timeUnits) {
    reversed[key] = -timeUnits[key];
  }
  return reversed;
}
function addImpliedTimeUnits(components, timeUnits) {
  const output = components.clone();
  let date = components.dayjs();
  for (const key in timeUnits) {
    date = date.add(timeUnits[key], key);
  }
  if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
    output.imply("day", date.date());
    output.imply("month", date.month() + 1);
    output.imply("year", date.year());
  }
  if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
    output.imply("second", date.second());
    output.imply("minute", date.minute());
    output.imply("hour", date.hour());
  }
  return output;
}

// node_modules/chrono-node/dist/esm/calculation/weekdays.js
function createParsingComponentsAtWeekday(reference, weekday, modifier) {
  const refDate = reference.getDateWithAdjustedTimezone();
  const daysToWeekday = getDaysToWeekday(refDate, weekday, modifier);
  let components = new ParsingComponents(reference);
  components = addImpliedTimeUnits(components, { "day": daysToWeekday });
  components.assign("weekday", weekday);
  return components;
}
function getDaysToWeekday(refDate, weekday, modifier) {
  const refWeekday = refDate.getDay();
  switch (modifier) {
    case "this":
      return getDaysForwardToWeekday(refDate, weekday);
    case "last":
      return getBackwardDaysToWeekday(refDate, weekday);
    case "next":
      if (refWeekday == Weekday.SUNDAY) {
        return weekday == Weekday.SUNDAY ? 7 : weekday;
      }
      if (refWeekday == Weekday.SATURDAY) {
        if (weekday == Weekday.SATURDAY)
          return 7;
        if (weekday == Weekday.SUNDAY)
          return 8;
        return 1 + weekday;
      }
      if (weekday < refWeekday && weekday != Weekday.SUNDAY) {
        return getDaysForwardToWeekday(refDate, weekday);
      } else {
        return getDaysForwardToWeekday(refDate, weekday) + 7;
      }
  }
  return getDaysToWeekdayClosest(refDate, weekday);
}
function getDaysToWeekdayClosest(refDate, weekday) {
  const backward = getBackwardDaysToWeekday(refDate, weekday);
  const forward = getDaysForwardToWeekday(refDate, weekday);
  return forward < -backward ? forward : backward;
}
function getDaysForwardToWeekday(refDate, weekday) {
  const refWeekday = refDate.getDay();
  let forwardCount = weekday - refWeekday;
  if (forwardCount < 0) {
    forwardCount += 7;
  }
  return forwardCount;
}
function getBackwardDaysToWeekday(refDate, weekday) {
  const refWeekday = refDate.getDay();
  let backwardCount = weekday - refWeekday;
  if (backwardCount >= 0) {
    backwardCount -= 7;
  }
  return backwardCount;
}

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENWeekdayParser.js
var PATTERN11 = new RegExp(`(?:(?:\\,|\\(|\\ï¼ˆ)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY)}|weekend|weekday)(?:\\s*(?:\\,|\\)|\\ï¼‰))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
var PREFIX_GROUP2 = 1;
var WEEKDAY_GROUP = 2;
var POSTFIX_GROUP = 3;
var ENWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN11;
  }
  innerExtract(context, match) {
    const prefix = match[PREFIX_GROUP2];
    const postfix = match[POSTFIX_GROUP];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "last" || modifierWord == "past") {
      modifier = "last";
    } else if (modifierWord == "next") {
      modifier = "next";
    } else if (modifierWord == "this") {
      modifier = "this";
    }
    const weekday_word = match[WEEKDAY_GROUP].toLowerCase();
    let weekday;
    if (WEEKDAY_DICTIONARY[weekday_word] !== void 0) {
      weekday = WEEKDAY_DICTIONARY[weekday_word];
    } else if (weekday_word == "weekend") {
      weekday = modifier == "last" ? Weekday.SUNDAY : Weekday.SATURDAY;
    } else if (weekday_word == "weekday") {
      const refWeekday = context.reference.getDateWithAdjustedTimezone().getDay();
      if (refWeekday == Weekday.SUNDAY || refWeekday == Weekday.SATURDAY) {
        weekday = modifier == "last" ? Weekday.FRIDAY : Weekday.MONDAY;
      } else {
        weekday = refWeekday - 1;
        weekday = modifier == "last" ? weekday - 1 : weekday + 1;
        weekday = weekday % 5 + 1;
      }
    } else {
      return null;
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENRelativeDateFormatParser.js
var import_dayjs10 = __toESM(require_dayjs_min(), 1);
var PATTERN12 = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
var MODIFIER_WORD_GROUP = 1;
var RELATIVE_WORD_GROUP = 2;
var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN12;
  }
  innerExtract(context, match) {
    const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
    const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY[unitWord];
    if (modifier == "next" || modifier.startsWith("after")) {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "last" || modifier == "past") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = (0, import_dayjs10.default)(context.reference.instant);
    if (unitWord.match(/week/i)) {
      date = date.add(-date.get("d"), "d");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.imply("year", date.year());
    } else if (unitWord.match(/month/i)) {
      date = date.add(-date.date() + 1, "d");
      components.imply("day", date.date());
      components.assign("year", date.year());
      components.assign("month", date.month() + 1);
    } else if (unitWord.match(/year/i)) {
      date = date.add(-date.date() + 1, "d");
      date = date.add(-date.month(), "month");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.assign("year", date.year());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/common/parsers/SlashDateFormatParser.js
var PATTERN13 = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
var OPENING_GROUP = 1;
var ENDING_GROUP = 5;
var FIRST_NUMBERS_GROUP = 2;
var SECOND_NUMBERS_GROUP = 3;
var YEAR_GROUP5 = 4;
var SlashDateFormatParser = class {
  groupNumberMonth;
  groupNumberDay;
  constructor(littleEndian) {
    this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
    this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
  }
  pattern() {
    return PATTERN13;
  }
  extract(context, match) {
    const index = match.index + match[OPENING_GROUP].length;
    const indexEnd = match.index + match[0].length - match[ENDING_GROUP].length;
    if (index > 0) {
      const textBefore = context.text.substring(0, index);
      if (textBefore.match("\\d/?$")) {
        return;
      }
    }
    if (indexEnd < context.text.length) {
      const textAfter = context.text.substring(indexEnd);
      if (textAfter.match("^/?\\d")) {
        return;
      }
    }
    const text = context.text.substring(index, indexEnd);
    if (text.match(/^\d\.\d$/) || text.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
      return;
    }
    if (!match[YEAR_GROUP5] && text.indexOf("/") < 0) {
      return;
    }
    const result = context.createParsingResult(index, text);
    let month = parseInt(match[this.groupNumberMonth]);
    let day = parseInt(match[this.groupNumberDay]);
    if (month < 1 || month > 12) {
      if (month > 12) {
        if (day >= 1 && day <= 12 && month <= 31) {
          [day, month] = [month, day];
        } else {
          return null;
        }
      }
    }
    if (day < 1 || day > 31) {
      return null;
    }
    result.start.assign("day", day);
    result.start.assign("month", month);
    if (match[YEAR_GROUP5]) {
      const rawYearNumber = parseInt(match[YEAR_GROUP5]);
      const year3 = findMostLikelyADYear(rawYearNumber);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    return result.addTag("parser/SlashDateFormatParser");
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
var PATTERN14 = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
var PATTERN_NO_ABBR = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  allowAbbreviations;
  constructor(allowAbbreviations = true) {
    super();
    this.allowAbbreviations = allowAbbreviations;
  }
  innerPattern() {
    return this.allowAbbreviations ? PATTERN14 : PATTERN_NO_ABBR;
  }
  innerExtract(context, match) {
    const prefix = match[1].toLowerCase();
    let duration = parseTimeUnits(match[2]);
    if (!duration) {
      return null;
    }
    switch (prefix) {
      case "last":
      case "past":
      case "-":
        duration = reverseDuration(duration);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, duration);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeAfterDateRefiner.js
function IsPositiveFollowingReference(result) {
  return result.text.match(/^[+-]/i) != null;
}
function IsNegativeFollowingReference(result) {
  return result.text.match(/^-/i) != null;
}
var ENMergeRelativeAfterDateRefiner = class extends MergingRefiner {
  shouldMergeResults(textBetween, currentResult, nextResult) {
    if (!textBetween.match(/^\s*$/i)) {
      return false;
    }
    return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);
  }
  mergeResults(textBetween, currentResult, nextResult, context) {
    let timeUnits = parseTimeUnits(nextResult.text);
    if (IsNegativeFollowingReference(nextResult)) {
      timeUnits = reverseTimeUnits(timeUnits);
    }
    const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(currentResult.start.date()), timeUnits);
    return new ParsingResult(currentResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeFollowByDateRefiner.js
function hasImpliedEarlierReferenceDate(result) {
  return result.text.match(/\s+(before|from)$/i) != null;
}
function hasImpliedLaterReferenceDate(result) {
  return result.text.match(/\s+(after|since)$/i) != null;
}
var ENMergeRelativeFollowByDateRefiner = class extends MergingRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
  shouldMergeResults(textBetween, currentResult, nextResult) {
    if (!textBetween.match(this.patternBetween())) {
      return false;
    }
    if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
      return false;
    }
    return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
  }
  mergeResults(textBetween, currentResult, nextResult) {
    let duration = parseTimeUnits(currentResult.text);
    if (hasImpliedEarlierReferenceDate(currentResult)) {
      duration = reverseDuration(duration);
    }
    const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(nextResult.start.date()), duration);
    return new ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENExtractYearSuffixRefiner.js
var YEAR_SUFFIX_PATTERN = new RegExp(`^\\s*(${YEAR_PATTERN})`, "i");
var YEAR_GROUP6 = 1;
var ENExtractYearSuffixRefiner = class {
  refine(context, results) {
    results.forEach(function(result) {
      if (!result.start.isDateWithUnknownYear()) {
        return;
      }
      const suffix = context.text.substring(result.index + result.text.length);
      const match = YEAR_SUFFIX_PATTERN.exec(suffix);
      if (!match) {
        return;
      }
      if (match[0].trim().length <= 3) {
        return;
      }
      context.debug(() => {
        console.log(`Extracting year: '${match[0]}' into : ${result}`);
      });
      const year3 = parseYear(match[YEAR_GROUP6]);
      if (result.end != null) {
        result.end.assign("year", year3);
      }
      result.start.assign("year", year3);
      result.text += match[0];
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENUnlikelyFormatFilter.js
var ENUnlikelyFormatFilter = class extends Filter {
  constructor() {
    super();
  }
  isValid(context, result) {
    const text = result.text.trim();
    if (text === context.text.trim()) {
      return true;
    }
    if (text.toLowerCase() === "may") {
      const textBefore = context.text.substring(0, result.index).trim();
      if (!textBefore.match(/\b(in)$/i)) {
        context.debug(() => {
          console.log(`Removing unlikely result: ${result}`);
        });
        return false;
      }
    }
    if (text.toLowerCase().endsWith("the second")) {
      const textAfter = context.text.substring(result.index + result.text.length).trim();
      if (textAfter.length > 0) {
        context.debug(() => {
          console.log(`Removing unlikely result: ${result}`);
        });
      }
      return false;
    }
    return true;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/configuration.js
var ENDefaultConfiguration = class {
  createCasualConfiguration(littleEndian = false) {
    const option = this.createConfiguration(false, littleEndian);
    option.parsers.push(new ENCasualDateParser());
    option.parsers.push(new ENCasualTimeParser());
    option.parsers.push(new ENMonthNameParser());
    option.parsers.push(new ENRelativeDateFormatParser());
    option.parsers.push(new ENTimeUnitCasualRelativeFormatParser());
    option.refiners.push(new ENUnlikelyFormatFilter());
    return option;
  }
  createConfiguration(strictMode = true, littleEndian = false) {
    const options = includeCommonConfiguration({
      parsers: [
        new SlashDateFormatParser(littleEndian),
        new ENTimeUnitWithinFormatParser(strictMode),
        new ENMonthNameLittleEndianParser(),
        new ENMonthNameMiddleEndianParser(littleEndian),
        new ENWeekdayParser(),
        new ENSlashMonthFormatParser(),
        new ENTimeExpressionParser(strictMode),
        new ENTimeUnitAgoFormatParser(strictMode),
        new ENTimeUnitLaterFormatParser(strictMode)
      ],
      refiners: [new ENMergeDateTimeRefiner()]
    }, strictMode);
    options.parsers.unshift(new ENYearMonthDayParser(strictMode));
    options.refiners.unshift(new ENMergeRelativeFollowByDateRefiner());
    options.refiners.unshift(new ENMergeRelativeAfterDateRefiner());
    options.refiners.unshift(new OverlapRemovalRefiner());
    options.refiners.push(new ENMergeDateTimeRefiner());
    options.refiners.push(new ENExtractYearSuffixRefiner());
    options.refiners.push(new ENMergeDateRangeRefiner());
    return options;
  }
};

// node_modules/chrono-node/dist/esm/chrono.js
var Chrono = class _Chrono {
  parsers;
  refiners;
  defaultConfig = new ENDefaultConfiguration();
  constructor(configuration2) {
    configuration2 = configuration2 || this.defaultConfig.createCasualConfiguration();
    this.parsers = [...configuration2.parsers];
    this.refiners = [...configuration2.refiners];
  }
  clone() {
    return new _Chrono({
      parsers: [...this.parsers],
      refiners: [...this.refiners]
    });
  }
  parseDate(text, referenceDate, option) {
    const results = this.parse(text, referenceDate, option);
    return results.length > 0 ? results[0].start.date() : null;
  }
  parse(text, referenceDate, option) {
    const context = new ParsingContext(text, referenceDate, option);
    let results = [];
    this.parsers.forEach((parser) => {
      const parsedResults = _Chrono.executeParser(context, parser);
      results = results.concat(parsedResults);
    });
    results.sort((a, b) => {
      return a.index - b.index;
    });
    this.refiners.forEach(function(refiner) {
      results = refiner.refine(context, results);
    });
    return results;
  }
  static executeParser(context, parser) {
    const results = [];
    const pattern = parser.pattern(context);
    const originalText = context.text;
    let remainingText = context.text;
    let match = pattern.exec(remainingText);
    while (match) {
      const index = match.index + originalText.length - remainingText.length;
      match.index = index;
      const result = parser.extract(context, match);
      if (!result) {
        remainingText = originalText.substring(match.index + 1);
        match = pattern.exec(remainingText);
        continue;
      }
      let parsedResult = null;
      if (result instanceof ParsingResult) {
        parsedResult = result;
      } else if (result instanceof ParsingComponents) {
        parsedResult = context.createParsingResult(match.index, match[0]);
        parsedResult.start = result;
      } else {
        parsedResult = context.createParsingResult(match.index, match[0], result);
      }
      const parsedIndex = parsedResult.index;
      const parsedText = parsedResult.text;
      context.debug(() => console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`));
      results.push(parsedResult);
      remainingText = originalText.substring(parsedIndex + parsedText.length);
      match = pattern.exec(remainingText);
    }
    return results;
  }
};
var ParsingContext = class {
  text;
  option;
  reference;
  refDate;
  constructor(text, refDate, option) {
    this.text = text;
    this.option = option ?? {};
    this.reference = ReferenceWithTimezone.fromInput(refDate, this.option.timezones);
    this.refDate = this.reference.instant;
  }
  createParsingComponents(components) {
    if (components instanceof ParsingComponents) {
      return components;
    }
    return new ParsingComponents(this.reference, components);
  }
  createParsingResult(index, textOrEndIndex, startComponents, endComponents) {
    const text = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);
    const start = startComponents ? this.createParsingComponents(startComponents) : null;
    const end = endComponents ? this.createParsingComponents(endComponents) : null;
    return new ParsingResult(this.reference, index, text, start, end);
  }
  debug(block) {
    if (this.option.debug) {
      if (this.option.debug instanceof Function) {
        this.option.debug(block);
      } else {
        const handler = this.option.debug;
        handler.debug(block);
      }
    }
  }
};

// node_modules/chrono-node/dist/esm/locales/en/index.js
var configuration = new ENDefaultConfiguration();
var casual = new Chrono(configuration.createCasualConfiguration(false));
var strict = new Chrono(configuration.createConfiguration(true, false));
var GB = new Chrono(configuration.createCasualConfiguration(true));
function parse(text, ref, option) {
  return casual.parse(text, ref, option);
}
function parseDate(text, ref, option) {
  return casual.parseDate(text, ref, option);
}

// node_modules/chrono-node/dist/esm/locales/de/index.js
var de_exports = {};
__export(de_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual2,
  createCasualConfiguration: () => createCasualConfiguration,
  createConfiguration: () => createConfiguration,
  parse: () => parse2,
  parseDate: () => parseDate2,
  strict: () => strict2
});

// node_modules/chrono-node/dist/esm/locales/de/parsers/DETimeExpressionParser.js
var DETimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:um|von)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\â€“|\\~|\\ã€œ|bis)\\s*";
  }
  extractPrimaryTimeComponents(context, match) {
    if (match[0].match(/^\s*\d{4}\s*$/)) {
      return null;
    }
    return super.extractPrimaryTimeComponents(context, match);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/constants.js
var WEEKDAY_DICTIONARY2 = {
  "sonntag": 0,
  "so": 0,
  "montag": 1,
  "mo": 1,
  "dienstag": 2,
  "di": 2,
  "mittwoch": 3,
  "mi": 3,
  "donnerstag": 4,
  "do": 4,
  "freitag": 5,
  "fr": 5,
  "samstag": 6,
  "sa": 6
};
var MONTH_DICTIONARY2 = {
  "januar": 1,
  "jÃ¤nner": 1,
  "janner": 1,
  "jan": 1,
  "jan.": 1,
  "februar": 2,
  "feber": 2,
  "feb": 2,
  "feb.": 2,
  "mÃ¤rz": 3,
  "maerz": 3,
  "mÃ¤r": 3,
  "mÃ¤r.": 3,
  "mrz": 3,
  "mrz.": 3,
  "april": 4,
  "apr": 4,
  "apr.": 4,
  "mai": 5,
  "juni": 6,
  "jun": 6,
  "jun.": 6,
  "juli": 7,
  "jul": 7,
  "jul.": 7,
  "august": 8,
  "aug": 8,
  "aug.": 8,
  "september": 9,
  "sep": 9,
  "sep.": 9,
  "sept": 9,
  "sept.": 9,
  "oktober": 10,
  "okt": 10,
  "okt.": 10,
  "november": 11,
  "nov": 11,
  "nov.": 11,
  "dezember": 12,
  "dez": 12,
  "dez.": 12
};
var INTEGER_WORD_DICTIONARY2 = {
  "eins": 1,
  "eine": 1,
  "einem": 1,
  "einen": 1,
  "einer": 1,
  "zwei": 2,
  "drei": 3,
  "vier": 4,
  "fÃ¼nf": 5,
  "fuenf": 5,
  "sechs": 6,
  "sieben": 7,
  "acht": 8,
  "neun": 9,
  "zehn": 10,
  "elf": 11,
  "zwÃ¶lf": 12,
  "zwoelf": 12
};
var TIME_UNIT_DICTIONARY2 = {
  sek: "second",
  sekunde: "second",
  sekunden: "second",
  min: "minute",
  minute: "minute",
  minuten: "minute",
  h: "hour",
  std: "hour",
  stunde: "hour",
  stunden: "hour",
  tag: "d",
  tage: "d",
  tagen: "d",
  woche: "week",
  wochen: "week",
  monat: "month",
  monate: "month",
  monaten: "month",
  monats: "month",
  quartal: "quarter",
  quartals: "quarter",
  quartale: "quarter",
  quartalen: "quarter",
  a: "year",
  j: "year",
  jr: "year",
  jahr: "year",
  jahre: "year",
  jahren: "year",
  jahres: "year"
};
var NUMBER_PATTERN2 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY2)}|[0-9]+|[0-9]+\\.[0-9]+|halb?|halbe?|einigen?|wenigen?|mehreren?)`;
function parseNumberPattern2(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY2[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY2[num];
  } else if (num === "ein" || num === "einer" || num === "einem" || num === "einen" || num === "eine") {
    return 1;
  } else if (num.match(/wenigen/)) {
    return 2;
  } else if (num.match(/halb/) || num.match(/halben/)) {
    return 0.5;
  } else if (num.match(/einigen/)) {
    return 3;
  } else if (num.match(/mehreren/)) {
    return 7;
  }
  return parseFloat(num);
}
var YEAR_PATTERN2 = `(?:[0-9]{1,4}(?:\\s*[vn]\\.?\\s*(?:C(?:hr)?|(?:u\\.?|d\\.?(?:\\s*g\\.?)?)?\\s*Z)\\.?|\\s*(?:u\\.?|d\\.?(?:\\s*g\\.)?)\\s*Z\\.?)?)`;
function parseYear2(match) {
  if (/v/i.test(match)) {
    return -parseInt(match.replace(/[^0-9]+/gi, ""));
  }
  if (/n/i.test(match)) {
    return parseInt(match.replace(/[^0-9]+/gi, ""));
  }
  if (/z/i.test(match)) {
    return parseInt(match.replace(/[^0-9]+/gi, ""));
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN2 = `(${NUMBER_PATTERN2})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY2)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX2 = new RegExp(SINGLE_TIME_UNIT_PATTERN2, "i");
var TIME_UNITS_PATTERN2 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN2);
function parseTimeUnits2(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX2.exec(remainingText);
  while (match) {
    collectDateTimeFragment2(fragments, match);
    remainingText = remainingText.substring(match[0].length);
    match = SINGLE_TIME_UNIT_REGEX2.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment2(fragments, match) {
  const num = parseNumberPattern2(match[1]);
  const unit = TIME_UNIT_DICTIONARY2[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/de/parsers/DEWeekdayParser.js
var PATTERN15 = new RegExp(`(?:(?:\\,|\\(|\\ï¼ˆ)\\s*)?(?:a[mn]\\s*?)?(?:(diese[mn]|letzte[mn]|n(?:Ã¤|ae)chste[mn])\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY2)})(?:\\s*(?:\\,|\\)|\\ï¼‰))?(?:\\s*(diese|letzte|n(?:Ã¤|ae)chste)\\s*woche)?(?=\\W|$)`, "i");
var PREFIX_GROUP3 = 1;
var SUFFIX_GROUP = 3;
var WEEKDAY_GROUP2 = 2;
var DEWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN15;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP2].toLowerCase();
    const offset = WEEKDAY_DICTIONARY2[dayOfWeek];
    const prefix = match[PREFIX_GROUP3];
    const postfix = match[SUFFIX_GROUP];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord.match(/letzte/)) {
      modifier = "last";
    } else if (modifierWord.match(/chste/)) {
      modifier = "next";
    } else if (modifierWord.match(/diese/)) {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, offset, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DESpecificTimeExpressionParser.js
var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:um|von)\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\â€“|\\~|\\ã€œ|bis(?:\\s+um)?|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
var HOUR_GROUP2 = 2;
var MINUTE_GROUP2 = 3;
var SECOND_GROUP2 = 4;
var AM_PM_HOUR_GROUP2 = 5;
var DESpecificTimeExpressionParser = class _DESpecificTimeExpressionParser {
  pattern(context) {
    return FIRST_REG_PATTERN;
  }
  extract(context, match) {
    const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
    if (result.text.match(/^\d{4}$/)) {
      match.index += match[0].length;
      return null;
    }
    result.start = _DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
    if (!result.start) {
      match.index += match[0].length;
      return null;
    }
    const remainingText = context.text.substring(match.index + match[0].length);
    const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
    if (secondMatch) {
      result.end = _DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
      if (result.end) {
        result.text += secondMatch[0];
      }
    }
    return result;
  }
  static extractTimeComponent(extractingComponents, match) {
    let hour = 0;
    let minute = 0;
    let meridiem = null;
    hour = parseInt(match[HOUR_GROUP2]);
    if (match[MINUTE_GROUP2] != null) {
      minute = parseInt(match[MINUTE_GROUP2]);
    }
    if (minute >= 60 || hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP2] != null) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP2].toLowerCase();
      if (ampm.match(/morgen|vormittag/)) {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
        }
      }
      if (ampm.match(/nachmittag|abend/)) {
        meridiem = Meridiem.PM;
        if (hour != 12) {
          hour += 12;
        }
      }
      if (ampm.match(/nacht/)) {
        if (hour == 12) {
          meridiem = Meridiem.AM;
          hour = 0;
        } else if (hour < 6) {
          meridiem = Meridiem.AM;
        } else {
          meridiem = Meridiem.PM;
          hour += 12;
        }
      }
    }
    extractingComponents.assign("hour", hour);
    extractingComponents.assign("minute", minute);
    if (meridiem !== null) {
      extractingComponents.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        extractingComponents.imply("meridiem", Meridiem.AM);
      } else {
        extractingComponents.imply("meridiem", Meridiem.PM);
      }
    }
    if (match[SECOND_GROUP2] != null) {
      const second = parseInt(match[SECOND_GROUP2]);
      if (second >= 60)
        return null;
      extractingComponents.assign("second", second);
    }
    return extractingComponents;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/refiners/DEMergeDateRangeRefiner.js
var DEMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(bis(?:\s*(?:am|zum))?|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/refiners/DEMergeDateTimeRefiner.js
var DEMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DECasualDateParser.js
var import_dayjs13 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/locales/de/parsers/DECasualTimeParser.js
var import_dayjs11 = __toESM(require_dayjs_min(), 1);
var DECasualTimeParser = class _DECasualTimeParser extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(diesen)?\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const targetDate = (0, import_dayjs11.default)(context.refDate);
    const timeKeywordPattern = match[2].toLowerCase();
    const component = context.createParsingComponents();
    implySimilarTime2(component, targetDate);
    return _DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);
  }
  static extractTimeComponents(component, timeKeywordPattern) {
    switch (timeKeywordPattern) {
      case "morgen":
        component.imply("hour", 6);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "vormittag":
        component.imply("hour", 9);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "mittag":
      case "mittags":
        component.imply("hour", 12);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "nachmittag":
        component.imply("hour", 15);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "abend":
        component.imply("hour", 18);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "nacht":
        component.imply("hour", 22);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "mitternacht":
        if (component.get("hour") > 1) {
          component = addImpliedTimeUnits(component, { "day": 1 });
        }
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DECasualDateParser.js
var PATTERN16 = new RegExp(`(jetzt|heute|morgen|Ã¼bermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?=\\W|$)`, "i");
var DATE_GROUP3 = 1;
var TIME_GROUP = 2;
var DECasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return PATTERN16;
  }
  innerExtract(context, match) {
    let targetDate = (0, import_dayjs13.default)(context.refDate);
    const dateKeyword = (match[DATE_GROUP3] || "").toLowerCase();
    const timeKeyword = (match[TIME_GROUP] || "").toLowerCase();
    let component = context.createParsingComponents();
    switch (dateKeyword) {
      case "jetzt":
        component = now(context.reference);
        break;
      case "heute":
        component = today(context.reference);
        break;
      case "morgen":
        assignTheNextDay(component, targetDate);
        break;
      case "Ã¼bermorgen":
      case "uebermorgen":
        targetDate = targetDate.add(1, "day");
        assignTheNextDay(component, targetDate);
        break;
      case "gestern":
        targetDate = targetDate.add(-1, "day");
        assignSimilarDate2(component, targetDate);
        implySimilarTime2(component, targetDate);
        break;
      case "vorgestern":
        targetDate = targetDate.add(-2, "day");
        assignSimilarDate2(component, targetDate);
        implySimilarTime2(component, targetDate);
        break;
      default:
        if (dateKeyword.match(/letzte\s*nacht/)) {
          if (targetDate.hour() > 6) {
            targetDate = targetDate.add(-1, "day");
          }
          assignSimilarDate2(component, targetDate);
          component.imply("hour", 0);
        }
        break;
    }
    if (timeKeyword) {
      component = DECasualTimeParser.extractTimeComponents(component, timeKeyword);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DEMonthNameLittleEndianParser.js
var PATTERN17 = new RegExp(`(?:am\\s*?)?(?:den\\s*?)?([0-9]{1,2})\\.(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\â€“|\\s)\\s*([0-9]{1,2})\\.?)?\\s*(${matchAnyPattern(MONTH_DICTIONARY2)})(?:(?:-|/|,?\\s*)(${YEAR_PATTERN2}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var DATE_GROUP4 = 1;
var DATE_TO_GROUP3 = 2;
var MONTH_NAME_GROUP5 = 3;
var YEAR_GROUP7 = 4;
var DEMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN17;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY2[match[MONTH_NAME_GROUP5].toLowerCase()];
    const day = parseInt(match[DATE_GROUP4]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP4].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP7]) {
      const yearNumber = parseYear2(match[YEAR_GROUP7]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP3]) {
      const endDate = parseInt(match[DATE_TO_GROUP3]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DETimeUnitRelativeFormatParser.js
var DETimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor() {
    super();
  }
  innerPattern() {
    return new RegExp(`(?:\\s*((?:nÃ¤chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\s*)?(${NUMBER_PATTERN2})?(?:\\s*(nÃ¤chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY2)})`, "i");
  }
  innerExtract(context, match) {
    const num = match[2] ? parseNumberPattern2(match[2]) : 1;
    const unit = TIME_UNIT_DICTIONARY2[match[4].toLowerCase()];
    let timeUnits = {};
    timeUnits[unit] = num;
    let modifier = match[1] || match[3] || "";
    modifier = modifier.toLowerCase();
    if (!modifier) {
      return;
    }
    if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {
      timeUnits = reverseTimeUnits(timeUnits);
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DETimeUnitWithinFormatParser.js
var DETimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:in|fÃ¼r|wÃ¤hrend)\\s*(${TIME_UNITS_PATTERN2})(?=\\W|$)`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits2(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/index.js
var casual2 = new Chrono(createCasualConfiguration());
var strict2 = new Chrono(createConfiguration(true));
function parse2(text, ref, option) {
  return casual2.parse(text, ref, option);
}
function parseDate2(text, ref, option) {
  return casual2.parseDate(text, ref, option);
}
function createCasualConfiguration(littleEndian = true) {
  const option = createConfiguration(false, littleEndian);
  option.parsers.unshift(new DECasualTimeParser());
  option.parsers.unshift(new DECasualDateParser());
  option.parsers.unshift(new DETimeUnitAgoFormatParser());
  return option;
}
function createConfiguration(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new ISOFormatParser(),
      new SlashDateFormatParser(littleEndian),
      new DETimeExpressionParser(),
      new DESpecificTimeExpressionParser(),
      new DEMonthNameLittleEndianParser(),
      new DEWeekdayParser(),
      new DETimeUnitWithinFormatParser()
    ],
    refiners: [new DEMergeDateRangeRefiner(), new DEMergeDateTimeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/fr/index.js
var fr_exports = {};
__export(fr_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual3,
  createCasualConfiguration: () => createCasualConfiguration2,
  createConfiguration: () => createConfiguration2,
  parse: () => parse3,
  parseDate: () => parseDate3,
  strict: () => strict3
});

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRCasualDateParser.js
var import_dayjs15 = __toESM(require_dayjs_min(), 1);
var FRCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(maintenant|aujourd'hui|demain|hier|cette\s*nuit|la\s*veille)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    let targetDate = (0, import_dayjs15.default)(context.refDate);
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "maintenant":
        return now(context.reference);
      case "aujourd'hui":
        return today(context.reference);
      case "hier":
        return yesterday(context.reference);
      case "demain":
        return tomorrow(context.reference);
      default:
        if (lowerText.match(/cette\s*nuit/)) {
          assignSimilarDate2(component, targetDate);
          component.imply("hour", 22);
          component.imply("meridiem", Meridiem.PM);
        } else if (lowerText.match(/la\s*veille/)) {
          targetDate = targetDate.add(-1, "day");
          assignSimilarDate2(component, targetDate);
          component.imply("hour", 0);
        }
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRCasualTimeParser.js
var FRCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(cet?)?\s*(matin|soir|aprÃ¨s-midi|aprem|a midi|Ã  minuit)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const suffixLower = match[2].toLowerCase();
    const component = context.createParsingComponents();
    switch (suffixLower) {
      case "aprÃ¨s-midi":
      case "aprem":
        component.imply("hour", 14);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "soir":
        component.imply("hour", 18);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "matin":
        component.imply("hour", 8);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "a midi":
        component.imply("hour", 12);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "Ã  minuit":
        component.imply("hour", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeExpressionParser.js
var FRTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:[Ã a])\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\â€“|\\~|\\ã€œ|[Ã a]|\\?)\\s*";
  }
  extractPrimaryTimeComponents(context, match) {
    if (match[0].match(/^\s*\d{4}\s*$/)) {
      return null;
    }
    return super.extractPrimaryTimeComponents(context, match);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/refiners/FRMergeDateTimeRefiner.js
var FRMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|Ã |a|au|vers|de|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/refiners/FRMergeDateRangeRefiner.js
var FRMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(Ã |a|au|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/constants.js
var WEEKDAY_DICTIONARY3 = {
  "dimanche": 0,
  "dim": 0,
  "lundi": 1,
  "lun": 1,
  "mardi": 2,
  "mar": 2,
  "mercredi": 3,
  "mer": 3,
  "jeudi": 4,
  "jeu": 4,
  "vendredi": 5,
  "ven": 5,
  "samedi": 6,
  "sam": 6
};
var MONTH_DICTIONARY3 = {
  "janvier": 1,
  "jan": 1,
  "jan.": 1,
  "fÃ©vrier": 2,
  "fÃ©v": 2,
  "fÃ©v.": 2,
  "fevrier": 2,
  "fev": 2,
  "fev.": 2,
  "mars": 3,
  "mar": 3,
  "mar.": 3,
  "avril": 4,
  "avr": 4,
  "avr.": 4,
  "mai": 5,
  "juin": 6,
  "jun": 6,
  "juillet": 7,
  "juil": 7,
  "jul": 7,
  "jul.": 7,
  "aoÃ»t": 8,
  "aout": 8,
  "septembre": 9,
  "sep": 9,
  "sep.": 9,
  "sept": 9,
  "sept.": 9,
  "octobre": 10,
  "oct": 10,
  "oct.": 10,
  "novembre": 11,
  "nov": 11,
  "nov.": 11,
  "dÃ©cembre": 12,
  "decembre": 12,
  "dec": 12,
  "dec.": 12
};
var INTEGER_WORD_DICTIONARY3 = {
  "un": 1,
  "deux": 2,
  "trois": 3,
  "quatre": 4,
  "cinq": 5,
  "six": 6,
  "sept": 7,
  "huit": 8,
  "neuf": 9,
  "dix": 10,
  "onze": 11,
  "douze": 12,
  "treize": 13
};
var TIME_UNIT_DICTIONARY3 = {
  "sec": "second",
  "seconde": "second",
  "secondes": "second",
  "min": "minute",
  "mins": "minute",
  "minute": "minute",
  "minutes": "minute",
  "h": "hour",
  "hr": "hour",
  "hrs": "hour",
  "heure": "hour",
  "heures": "hour",
  "jour": "d",
  "jours": "d",
  "semaine": "week",
  "semaines": "week",
  "mois": "month",
  "trimestre": "quarter",
  "trimestres": "quarter",
  "ans": "year",
  "annÃ©e": "year",
  "annÃ©es": "year"
};
var NUMBER_PATTERN3 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY3)}|[0-9]+|[0-9]+\\.[0-9]+|une?\\b|quelques?|demi-?)`;
function parseNumberPattern3(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY3[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY3[num];
  } else if (num === "une" || num === "un") {
    return 1;
  } else if (num.match(/quelques?/)) {
    return 3;
  } else if (num.match(/demi-?/)) {
    return 0.5;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN2 = `(?:[0-9]{1,2}(?:er)?)`;
function parseOrdinalNumberPattern2(match) {
  let num = match.toLowerCase();
  num = num.replace(/(?:er)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN3 = `(?:[1-9][0-9]{0,3}\\s*(?:AC|AD|p\\.\\s*C(?:hr?)?\\.\\s*n\\.)|[1-2][0-9]{3}|[5-9][0-9])`;
function parseYear3(match) {
  if (/AC/i.test(match)) {
    match = match.replace(/BC/i, "");
    return -parseInt(match);
  }
  if (/AD/i.test(match) || /C/i.test(match)) {
    match = match.replace(/[^\d]+/i, "");
    return parseInt(match);
  }
  let yearNumber = parseInt(match);
  if (yearNumber < 100) {
    if (yearNumber > 50) {
      yearNumber = yearNumber + 1900;
    } else {
      yearNumber = yearNumber + 2e3;
    }
  }
  return yearNumber;
}
var SINGLE_TIME_UNIT_PATTERN3 = `(${NUMBER_PATTERN3})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY3)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX3 = new RegExp(SINGLE_TIME_UNIT_PATTERN3, "i");
var TIME_UNITS_PATTERN3 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN3);
function parseTimeUnits3(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX3.exec(remainingText);
  while (match) {
    collectDateTimeFragment3(fragments, match);
    remainingText = remainingText.substring(match[0].length);
    match = SINGLE_TIME_UNIT_REGEX3.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment3(fragments, match) {
  const num = parseNumberPattern3(match[1]);
  const unit = TIME_UNIT_DICTIONARY3[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRWeekdayParser.js
var PATTERN18 = new RegExp(`(?:(?:\\,|\\(|\\ï¼ˆ)\\s*)?(?:(?:ce)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY3)})(?:\\s*(?:\\,|\\)|\\ï¼‰))?(?:\\s*(dernier|prochain)\\s*)?(?=\\W|\\d|$)`, "i");
var WEEKDAY_GROUP3 = 1;
var POSTFIX_GROUP2 = 2;
var FRWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN18;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP3].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY3[dayOfWeek];
    if (weekday === void 0) {
      return null;
    }
    let suffix = match[POSTFIX_GROUP2];
    suffix = suffix || "";
    suffix = suffix.toLowerCase();
    let modifier = null;
    if (suffix == "dernier") {
      modifier = "last";
    } else if (suffix == "prochain") {
      modifier = "next";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRSpecificTimeExpressionParser.js
var FIRST_REG_PATTERN2 = new RegExp("(^|\\s|T)(?:(?:[Ã a])\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
var SECOND_REG_PATTERN2 = new RegExp("^\\s*(\\-|\\â€“|\\~|\\ã€œ|[Ã a]|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
var HOUR_GROUP3 = 2;
var MINUTE_GROUP3 = 3;
var SECOND_GROUP3 = 4;
var AM_PM_HOUR_GROUP3 = 5;
var FRSpecificTimeExpressionParser = class _FRSpecificTimeExpressionParser {
  pattern(context) {
    return FIRST_REG_PATTERN2;
  }
  extract(context, match) {
    const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
    if (result.text.match(/^\d{4}$/)) {
      match.index += match[0].length;
      return null;
    }
    result.start = _FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
    if (!result.start) {
      match.index += match[0].length;
      return null;
    }
    const remainingText = context.text.substring(match.index + match[0].length);
    const secondMatch = SECOND_REG_PATTERN2.exec(remainingText);
    if (secondMatch) {
      result.end = _FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
      if (result.end) {
        result.text += secondMatch[0];
      }
    }
    return result;
  }
  static extractTimeComponent(extractingComponents, match) {
    let hour = 0;
    let minute = 0;
    let meridiem = null;
    hour = parseInt(match[HOUR_GROUP3]);
    if (match[MINUTE_GROUP3] != null) {
      minute = parseInt(match[MINUTE_GROUP3]);
    }
    if (minute >= 60 || hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP3] != null) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP3][0].toLowerCase();
      if (ampm == "a") {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
        }
      }
      if (ampm == "p") {
        meridiem = Meridiem.PM;
        if (hour != 12) {
          hour += 12;
        }
      }
    }
    extractingComponents.assign("hour", hour);
    extractingComponents.assign("minute", minute);
    if (meridiem !== null) {
      extractingComponents.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        extractingComponents.imply("meridiem", Meridiem.AM);
      } else {
        extractingComponents.imply("meridiem", Meridiem.PM);
      }
    }
    if (match[SECOND_GROUP3] != null) {
      const second = parseInt(match[SECOND_GROUP3]);
      if (second >= 60)
        return null;
      extractingComponents.assign("second", second);
    }
    return extractingComponents;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRMonthNameLittleEndianParser.js
var PATTERN19 = new RegExp(`(?:on\\s*?)?(${ORDINAL_NUMBER_PATTERN2})(?:\\s*(?:au|\\-|\\â€“|jusqu'au?|\\s)\\s*(${ORDINAL_NUMBER_PATTERN2}))?(?:-|/|\\s*(?:de)?\\s*)(${matchAnyPattern(MONTH_DICTIONARY3)})(?:(?:-|/|,?\\s*)(${YEAR_PATTERN3}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var DATE_GROUP5 = 1;
var DATE_TO_GROUP4 = 2;
var MONTH_NAME_GROUP6 = 3;
var YEAR_GROUP8 = 4;
var FRMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN19;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY3[match[MONTH_NAME_GROUP6].toLowerCase()];
    const day = parseOrdinalNumberPattern2(match[DATE_GROUP5]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP5].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP8]) {
      const yearNumber = parseYear3(match[YEAR_GROUP8]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP4]) {
      const endDate = parseOrdinalNumberPattern2(match[DATE_TO_GROUP4]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeUnitAgoFormatParser.js
var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor() {
    super();
  }
  innerPattern() {
    return new RegExp(`il y a\\s*(${TIME_UNITS_PATTERN3})(?=(?:\\W|$))`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits3(match[1]);
    const outputTimeUnits = reverseTimeUnits(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeUnitWithinFormatParser.js
var FRTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:dans|en|pour|pendant|de)\\s*(${TIME_UNITS_PATTERN3})(?=\\W|$)`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits3(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js
var FRTimeUnitAgoFormatParser2 = class extends AbstractParserWithWordBoundaryChecking {
  constructor() {
    super();
  }
  innerPattern() {
    return new RegExp(`(?:les?|la|l'|du|des?)\\s*(${NUMBER_PATTERN3})?(?:\\s*(prochaine?s?|derni[eÃ¨]re?s?|pass[Ã©e]e?s?|pr[Ã©e]c[Ã©e]dents?|suivante?s?))?\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY3)})(?:\\s*(prochaine?s?|derni[eÃ¨]re?s?|pass[Ã©e]e?s?|pr[Ã©e]c[Ã©e]dents?|suivante?s?))?`, "i");
  }
  innerExtract(context, match) {
    const num = match[1] ? parseNumberPattern3(match[1]) : 1;
    const unit = TIME_UNIT_DICTIONARY3[match[3].toLowerCase()];
    let timeUnits = {};
    timeUnits[unit] = num;
    let modifier = match[2] || match[4] || "";
    modifier = modifier.toLowerCase();
    if (!modifier) {
      return;
    }
    if (/derni[eÃ¨]re?s?/.test(modifier) || /pass[Ã©e]e?s?/.test(modifier) || /pr[Ã©e]c[Ã©e]dents?/.test(modifier)) {
      timeUnits = reverseTimeUnits(timeUnits);
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/index.js
var casual3 = new Chrono(createCasualConfiguration2());
var strict3 = new Chrono(createConfiguration2(true));
function parse3(text, ref, option) {
  return casual3.parse(text, ref, option);
}
function parseDate3(text, ref, option) {
  return casual3.parseDate(text, ref, option);
}
function createCasualConfiguration2(littleEndian = true) {
  const option = createConfiguration2(false, littleEndian);
  option.parsers.unshift(new FRCasualDateParser());
  option.parsers.unshift(new FRCasualTimeParser());
  option.parsers.unshift(new FRTimeUnitAgoFormatParser2());
  return option;
}
function createConfiguration2(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new FRMonthNameLittleEndianParser(),
      new FRTimeExpressionParser(),
      new FRSpecificTimeExpressionParser(),
      new FRTimeUnitAgoFormatParser(),
      new FRTimeUnitWithinFormatParser(),
      new FRWeekdayParser()
    ],
    refiners: [new FRMergeDateTimeRefiner(), new FRMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/ja/index.js
var ja_exports = {};
__export(ja_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual4,
  createCasualConfiguration: () => createCasualConfiguration3,
  createConfiguration: () => createConfiguration3,
  parse: () => parse4,
  parseDate: () => parseDate4,
  strict: () => strict4
});

// node_modules/chrono-node/dist/esm/locales/ja/constants.js
var NUMBER = {
  "é›¶": 0,
  "ã€‡": 0,
  "ä¸€": 1,
  "äºŒ": 2,
  "ä¸‰": 3,
  "å››": 4,
  "äº”": 5,
  "å…­": 6,
  "ä¸ƒ": 7,
  "å…«": 8,
  "ä¹": 9,
  "å": 10
};
var WEEKDAY_OFFSET = {
  "æ—¥": 0,
  "æœˆ": 1,
  "ç«": 2,
  "æ°´": 3,
  "æœ¨": 4,
  "é‡‘": 5,
  "åœŸ": 6
};
function toHankaku(text) {
  return String(text).replace(/\u2019/g, "'").replace(/\u201D/g, '"').replace(/\u3000/g, " ").replace(/\uFFE5/g, "Â¥").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
}
function alphaNum(token) {
  return String.fromCharCode(token.charCodeAt(0) - 65248);
}
function jaStringToNumber(text) {
  let number = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (char === "å") {
      number = number === 0 ? NUMBER[char] : number * NUMBER[char];
    } else {
      number += NUMBER[char];
    }
  }
  return number;
}

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPStandardParser.js
var import_dayjs17 = __toESM(require_dayjs_min(), 1);
var PATTERN20 = /(?:(?:([åŒä»Šæœ¬])|((æ˜­å’Œ|å¹³æˆ|ä»¤å’Œ)?([0-9ï¼-ï¼™]{1,4}|å…ƒ)))å¹´\s*)?([0-9ï¼-ï¼™]{1,2})æœˆ\s*([0-9ï¼-ï¼™]{1,2})æ—¥/i;
var SPECIAL_YEAR_GROUP = 1;
var TYPICAL_YEAR_GROUP = 2;
var ERA_GROUP = 3;
var YEAR_NUMBER_GROUP3 = 4;
var MONTH_GROUP2 = 5;
var DAY_GROUP = 6;
var JPStandardParser = class {
  pattern() {
    return PATTERN20;
  }
  extract(context, match) {
    const month = parseInt(toHankaku(match[MONTH_GROUP2]));
    const day = parseInt(toHankaku(match[DAY_GROUP]));
    const components = context.createParsingComponents({
      day,
      month
    });
    if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match("åŒ|ä»Š|æœ¬")) {
      const moment = (0, import_dayjs17.default)(context.refDate);
      components.assign("year", moment.year());
    }
    if (match[TYPICAL_YEAR_GROUP]) {
      const yearNumText = match[YEAR_NUMBER_GROUP3];
      let year3 = yearNumText == "å…ƒ" ? 1 : parseInt(toHankaku(yearNumText));
      if (match[ERA_GROUP] == "ä»¤å’Œ") {
        year3 += 2018;
      } else if (match[ERA_GROUP] == "å¹³æˆ") {
        year3 += 1988;
      } else if (match[ERA_GROUP] == "æ˜­å’Œ") {
        year3 += 1925;
      }
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      components.imply("year", year3);
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/refiners/JPMergeDateRangeRefiner.js
var JPMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(ã‹ã‚‰|ï¼|ãƒ¼|-|ï½ž|~)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPCasualDateParser.js
var import_dayjs18 = __toESM(require_dayjs_min(), 1);
var PATTERN21 = /ä»Šæ—¥|ãã‚‡ã†|æœ¬æ—¥|ã»ã‚“ã˜ã¤|æ˜¨æ—¥|ãã®ã†|æ˜Žæ—¥|ã‚ã—ãŸ|ä»Šå¤œ|ã“ã‚“ã‚„|ä»Šå¤•|ã“ã‚“ã‚†ã†|ä»Šæ™©|ã“ã‚“ã°ã‚“|ä»Šæœ|ã‘ã•/i;
function normalizeTextToKanji(text) {
  switch (text) {
    case "ãã‚‡ã†":
      return "ä»Šæ—¥";
    case "ã»ã‚“ã˜ã¤":
      return "æœ¬æ—¥";
    case "ãã®ã†":
      return "æ˜¨æ—¥";
    case "ã‚ã—ãŸ":
      return "æ˜Žæ—¥";
    case "ã“ã‚“ã‚„":
      return "ä»Šå¤œ";
    case "ã“ã‚“ã‚†ã†":
      return "ä»Šå¤•";
    case "ã“ã‚“ã°ã‚“":
      return "ä»Šæ™©";
    case "ã‘ã•":
      return "ä»Šæœ";
    default:
      return text;
  }
}
var JPCasualDateParser = class {
  pattern() {
    return PATTERN21;
  }
  extract(context, match) {
    const text = normalizeTextToKanji(match[0]);
    const date = (0, import_dayjs18.default)(context.refDate);
    const components = context.createParsingComponents();
    switch (text) {
      case "æ˜¨æ—¥":
        return yesterday(context.reference);
      case "æ˜Žæ—¥":
        return tomorrow(context.reference);
      case "æœ¬æ—¥":
      case "ä»Šæ—¥":
        return today(context.reference);
    }
    if (text == "ä»Šå¤œ" || text == "ä»Šå¤•" || text == "ä»Šæ™©") {
      components.imply("hour", 22);
      components.assign("meridiem", Meridiem.PM);
    } else if (text.match("ä»Šæœ")) {
      components.imply("hour", 6);
      components.assign("meridiem", Meridiem.AM);
    }
    components.assign("day", date.date());
    components.assign("month", date.month() + 1);
    components.assign("year", date.year());
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPWeekdayParser.js
var PATTERN22 = new RegExp("((?<prefix>å‰ã®|æ¬¡ã®|ä»Šé€±))?(?<weekday>" + Object.keys(WEEKDAY_OFFSET).join("|") + ")(?:æ›œæ—¥|æ›œ)", "i");
var JPWeekdayParser = class {
  pattern() {
    return PATTERN22;
  }
  extract(context, match) {
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET[dayOfWeek];
    if (offset === void 0)
      return null;
    const prefix = match.groups.prefix || "";
    let modifier = null;
    if (prefix.match(/å‰ã®/)) {
      modifier = "last";
    } else if (prefix.match(/æ¬¡ã®/)) {
      modifier = "next";
    } else if (prefix.match(/ä»Šé€±/)) {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, offset, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPSlashDateFormatParser.js
var PATTERN23 = new RegExp("([0-9ï¼-ï¼™]{4}[\\/|\\ï¼])?([0-1ï¼-ï¼‘]{0,1}[0-9ï¼-ï¼™]{1})(?:[\\/|\\ï¼]([0-3ï¼-ï¼“]{0,1}[0-9ï¼-ï¼™]{1}))", "i");
var YEAR_GROUP9 = 1;
var MONTH_GROUP3 = 2;
var DAY_GROUP2 = 3;
var JPSlashDateFormatParser = class {
  pattern() {
    return PATTERN23;
  }
  extract(context, match) {
    const result = context.createParsingComponents();
    const month = parseInt(toHankaku(match[MONTH_GROUP3]));
    const day = parseInt(toHankaku(match[DAY_GROUP2]));
    if (month < 1 || month > 12) {
      return null;
    }
    if (day < 1 || day > 31) {
      return null;
    }
    result.assign("day", day);
    result.assign("month", month);
    if (match[YEAR_GROUP9]) {
      const rawYearNumber = parseInt(toHankaku(match[YEAR_GROUP9]));
      const year3 = findMostLikelyADYear(rawYearNumber);
      result.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.reference.instant, day, month);
      result.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPTimeExpressionParser.js
var FIRST_REG_PATTERN3 = new RegExp("(?:(åˆå‰|åˆå¾Œ|A.M.|P.M.|AM|PM))?(?:[\\s,ï¼Œã€]*)(?:([0-9ï¼-ï¼™]+|[" + Object.keys(NUMBER).join("") + "]+)(?:\\s*)(?:æ™‚|:|ï¼š)(?:\\s*)([0-9ï¼-ï¼™]+|åŠ|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:åˆ†|:|ï¼š)?(?:\\s*)([0-9ï¼-ï¼™]+|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:ç§’)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var SECOND_REG_PATTERN3 = new RegExp("(?:^\\s*(?:ã‹ã‚‰|\\-|\\â€“|\\ï¼|\\~|\\ã€œ)\\s*)(?:(åˆå‰|åˆå¾Œ|A.M.|P.M.|AM|PM))?(?:[\\s,ï¼Œã€]*)(?:([0-9ï¼-ï¼™]+|[" + Object.keys(NUMBER).join("") + "]+)(?:\\s*)(?:æ™‚|:|ï¼š)(?:\\s*)([0-9ï¼-ï¼™]+|åŠ|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:åˆ†|:|ï¼š)?(?:\\s*)([0-9ï¼-ï¼™]+|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:ç§’)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var AM_PM_HOUR_GROUP_1 = 1;
var HOUR_GROUP4 = 2;
var MINUTE_GROUP4 = 3;
var SECOND_GROUP4 = 4;
var AM_PM_HOUR_GROUP_2 = 5;
var JPTimeExpressionParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return FIRST_REG_PATTERN3;
  }
  innerExtract(context, match) {
    if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
      return null;
    }
    const result = context.createParsingResult(match.index, match[0]);
    let hour = 0;
    let minute = 0;
    let meridiem = -1;
    if (match[SECOND_GROUP4]) {
      let second = parseInt(toHankaku(match[SECOND_GROUP4]));
      if (isNaN(second)) {
        second = jaStringToNumber(match[SECOND_GROUP4]);
      }
      if (second >= 60)
        return null;
      result.start.assign("second", second);
    }
    hour = parseInt(toHankaku(match[HOUR_GROUP4]));
    if (isNaN(hour)) {
      hour = jaStringToNumber(match[HOUR_GROUP4]);
    }
    if (match[MINUTE_GROUP4]) {
      if (match[MINUTE_GROUP4] === "åŠ") {
        minute = 30;
      } else {
        minute = parseInt(toHankaku(match[MINUTE_GROUP4]));
        if (isNaN(minute)) {
          minute = jaStringToNumber(match[MINUTE_GROUP4]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP_1]) {
      if (hour > 12)
        return null;
      const AMPMString = match[AM_PM_HOUR_GROUP_1];
      const FirstAMPMString = AMPMString[0].toLowerCase();
      if (AMPMString === "åˆå‰" || FirstAMPMString === "a") {
        meridiem = Meridiem.AM;
        if (hour === 12)
          hour = 0;
      } else if (AMPMString === "åˆå¾Œ" || FirstAMPMString === "p") {
        meridiem = Meridiem.PM;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[AM_PM_HOUR_GROUP_2]) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP_2][0].toLowerCase();
      if (ampm === "a") {
        meridiem = Meridiem.AM;
        if (hour === 12)
          hour = 0;
      }
      if (ampm === "p") {
        meridiem = Meridiem.PM;
        if (hour != 12)
          hour += 12;
      }
    }
    result.start.assign("hour", hour);
    result.start.assign("minute", minute);
    if (meridiem >= 0) {
      result.start.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        result.start.imply("meridiem", 0);
      } else {
        result.start.imply("meridiem", 1);
      }
    }
    match = SECOND_REG_PATTERN3.exec(context.text.substring(result.index + result.text.length));
    if (!match) {
      if (result.text.match(/^\d+$/)) {
        return null;
      }
      return result;
    }
    result.end = context.createParsingComponents();
    hour = 0;
    minute = 0;
    meridiem = -1;
    if (match[SECOND_GROUP4]) {
      let second = parseInt(toHankaku(match[SECOND_GROUP4]));
      if (isNaN(second)) {
        second = jaStringToNumber(match[SECOND_GROUP4]);
      }
      if (second >= 60)
        return null;
      result.end.assign("second", second);
    }
    hour = parseInt(toHankaku(match[HOUR_GROUP4]));
    if (isNaN(hour)) {
      hour = jaStringToNumber(match[HOUR_GROUP4]);
    }
    if (match[MINUTE_GROUP4]) {
      if (match[MINUTE_GROUP4] === "åŠ") {
        minute = 30;
      } else {
        minute = parseInt(toHankaku(match[MINUTE_GROUP4]));
        if (isNaN(minute)) {
          minute = jaStringToNumber(match[MINUTE_GROUP4]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP_1]) {
      if (hour > 12)
        return null;
      const AMPMString = match[AM_PM_HOUR_GROUP_1];
      const FirstAMPMString = AMPMString[0].toLowerCase();
      if (AMPMString === "åˆå‰" || FirstAMPMString === "a") {
        meridiem = Meridiem.AM;
        if (hour === 12)
          hour = 0;
      } else if (AMPMString === "åˆå¾Œ" || FirstAMPMString === "p") {
        meridiem = Meridiem.PM;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem === Meridiem.AM) {
          result.start.imply("meridiem", Meridiem.AM);
          if (result.start.get("hour") === 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", 1);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    } else if (match[AM_PM_HOUR_GROUP_2]) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP_2][0].toLowerCase();
      if (ampm === "a") {
        meridiem = Meridiem.AM;
        if (hour === 12)
          hour = 0;
      }
      if (ampm === "p") {
        meridiem = Meridiem.PM;
        if (hour != 12)
          hour += 12;
      }
    }
    result.text = result.text + match[0];
    result.end.assign("hour", hour);
    result.end.assign("minute", minute);
    if (meridiem >= 0) {
      result.end.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
      if (startAtPM) {
        if (result.start.get("hour") - 12 > hour) {
          result.end.imply("meridiem", Meridiem.AM);
        } else if (hour <= 12) {
          result.end.assign("hour", hour + 12);
          result.end.assign("meridiem", Meridiem.PM);
        }
      } else if (hour > 12) {
        result.end.imply("meridiem", Meridiem.PM);
      } else if (hour <= 12) {
        result.end.imply("meridiem", Meridiem.AM);
      }
    }
    if (result.end.date().getTime() < result.start.date().getTime()) {
      result.end.imply("day", result.end.get("day") + 1);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/refiners/JPMergeDateTimeRefiner.js
var JPMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return /^\s*(ã®)?\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/refiners/JPMergeWeekdayComponentRefiner.js
var JPMergeWeekdayComponentRefiner = class extends MergingRefiner {
  mergeResults(textBetween, currentResult, nextResult) {
    const newResult = currentResult.clone();
    newResult.text = currentResult.text + textBetween + nextResult.text;
    newResult.start.assign("weekday", nextResult.start.get("weekday"));
    if (newResult.end) {
      newResult.end.assign("weekday", nextResult.start.get("weekday"));
    }
    return newResult;
  }
  shouldMergeResults(textBetween, currentResult, nextResult) {
    const normalDateThenWeekday = currentResult.start.isCertain("day") && nextResult.start.isOnlyWeekdayComponent() && !nextResult.start.isCertain("hour");
    return normalDateThenWeekday && textBetween.match(/^[,ã€ã®]?\s*$/) !== null;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPWeekdayWithParenthesesParser.js
var PATTERN24 = new RegExp("(?:\\(|\\ï¼ˆ)(?<weekday>" + Object.keys(WEEKDAY_OFFSET).join("|") + ")(?:\\)|\\ï¼‰)", "i");
var JPWeekdayWithParenthesesParser = class {
  pattern() {
    return PATTERN24;
  }
  extract(context, match) {
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET[dayOfWeek];
    if (offset === void 0)
      return null;
    return createParsingComponentsAtWeekday(context.reference, offset);
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/index.js
var casual4 = new Chrono(createCasualConfiguration3());
var strict4 = new Chrono(createConfiguration3(true));
function parse4(text, ref, option) {
  return casual4.parse(text, ref, option);
}
function parseDate4(text, ref, option) {
  return casual4.parseDate(text, ref, option);
}
function createCasualConfiguration3() {
  const option = createConfiguration3(false);
  option.parsers.unshift(new JPCasualDateParser());
  return option;
}
function createConfiguration3(strictMode = true) {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new JPStandardParser(),
      new JPWeekdayParser(),
      new JPWeekdayWithParenthesesParser(),
      new JPSlashDateFormatParser(),
      new JPTimeExpressionParser()
    ],
    refiners: [
      new JPMergeWeekdayComponentRefiner(),
      new JPMergeDateTimeRefiner(),
      new JPMergeDateRangeRefiner()
    ]
  }, strictMode);
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof MergeWeekdayComponentRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/pt/index.js
var pt_exports = {};
__export(pt_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual5,
  createCasualConfiguration: () => createCasualConfiguration4,
  createConfiguration: () => createConfiguration4,
  parse: () => parse5,
  parseDate: () => parseDate5,
  strict: () => strict5
});

// node_modules/chrono-node/dist/esm/locales/pt/constants.js
var WEEKDAY_DICTIONARY4 = {
  "domingo": 0,
  "dom": 0,
  "segunda": 1,
  "segunda-feira": 1,
  "seg": 1,
  "terÃ§a": 2,
  "terÃ§a-feira": 2,
  "ter": 2,
  "quarta": 3,
  "quarta-feira": 3,
  "qua": 3,
  "quinta": 4,
  "quinta-feira": 4,
  "qui": 4,
  "sexta": 5,
  "sexta-feira": 5,
  "sex": 5,
  "sÃ¡bado": 6,
  "sabado": 6,
  "sab": 6
};
var MONTH_DICTIONARY4 = {
  "janeiro": 1,
  "jan": 1,
  "jan.": 1,
  "fevereiro": 2,
  "fev": 2,
  "fev.": 2,
  "marÃ§o": 3,
  "mar": 3,
  "mar.": 3,
  "abril": 4,
  "abr": 4,
  "abr.": 4,
  "maio": 5,
  "mai": 5,
  "mai.": 5,
  "junho": 6,
  "jun": 6,
  "jun.": 6,
  "julho": 7,
  "jul": 7,
  "jul.": 7,
  "agosto": 8,
  "ago": 8,
  "ago.": 8,
  "setembro": 9,
  "set": 9,
  "set.": 9,
  "outubro": 10,
  "out": 10,
  "out.": 10,
  "novembro": 11,
  "nov": 11,
  "nov.": 11,
  "dezembro": 12,
  "dez": 12,
  "dez.": 12
};
var YEAR_PATTERN4 = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
function parseYear4(match) {
  if (match.match(/^[0-9]{1,4}$/)) {
    let yearNumber = parseInt(match);
    if (yearNumber < 100) {
      if (yearNumber > 50) {
        yearNumber = yearNumber + 1900;
      } else {
        yearNumber = yearNumber + 2e3;
      }
    }
    return yearNumber;
  }
  if (match.match(/a\.?\s*c\.?/i)) {
    match = match.replace(/a\.?\s*c\.?/i, "");
    return -parseInt(match);
  }
  return parseInt(match);
}

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTWeekdayParser.js
var PATTERN25 = new RegExp(`(?:(?:\\,|\\(|\\ï¼ˆ)\\s*)?(?:(este|esta|passado|pr[oÃ³]ximo)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY4)})(?:\\s*(?:\\,|\\)|\\ï¼‰))?(?:\\s*(este|esta|passado|pr[Ã³o]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
var PREFIX_GROUP4 = 1;
var WEEKDAY_GROUP4 = 2;
var POSTFIX_GROUP3 = 3;
var PTWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN25;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP4].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY4[dayOfWeek];
    if (weekday === void 0) {
      return null;
    }
    const prefix = match[PREFIX_GROUP4];
    const postfix = match[POSTFIX_GROUP3];
    let norm = prefix || postfix || "";
    norm = norm.toLowerCase();
    let modifier = null;
    if (norm == "passado") {
      modifier = "this";
    } else if (norm == "prÃ³ximo" || norm == "proximo") {
      modifier = "next";
    } else if (norm == "este") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTTimeExpressionParser.js
var PTTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:ao?|Ã s?|das|da|de|do)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\â€“|\\~|\\ã€œ|a(?:o)?|\\?)\\s*";
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/refiners/PTMergeDateTimeRefiner.js
var PTMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(?:,|Ã )?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/refiners/PTMergeDateRangeRefiner.js
var PTMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(?:-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTMonthNameLittleEndianParser.js
var PATTERN26 = new RegExp(`([0-9]{1,2})(?:Âº|Âª|Â°)?(?:\\s*(?:desde|de|\\-|\\â€“|ao?|\\s)\\s*([0-9]{1,2})(?:Âº|Âª|Â°)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${matchAnyPattern(MONTH_DICTIONARY4)})(?:\\s*(?:de|,)?\\s*(${YEAR_PATTERN4}))?(?=\\W|$)`, "i");
var DATE_GROUP6 = 1;
var DATE_TO_GROUP5 = 2;
var MONTH_NAME_GROUP7 = 3;
var YEAR_GROUP10 = 4;
var PTMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN26;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY4[match[MONTH_NAME_GROUP7].toLowerCase()];
    const day = parseInt(match[DATE_GROUP6]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP6].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP10]) {
      const yearNumber = parseYear4(match[YEAR_GROUP10]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP5]) {
      const endDate = parseInt(match[DATE_TO_GROUP5]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTCasualDateParser.js
var PTCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(agora|hoje|amanha|amanhÃ£|ontem)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "agora":
        return now(context.reference);
      case "hoje":
        return today(context.reference);
      case "amanha":
      case "amanhÃ£":
        return tomorrow(context.reference);
      case "ontem":
        return yesterday(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTCasualTimeParser.js
var import_dayjs20 = __toESM(require_dayjs_min(), 1);
var PTCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return /(?:esta\s*)?(manha|manhÃ£|tarde|meia-noite|meio-dia|noite)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const targetDate = (0, import_dayjs20.default)(context.refDate);
    const component = context.createParsingComponents();
    switch (match[1].toLowerCase()) {
      case "tarde":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "noite":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 22);
        break;
      case "manha":
      case "manhÃ£":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "meia-noite":
        assignTheNextDay(component, targetDate);
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        break;
      case "meio-dia":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/index.js
var casual5 = new Chrono(createCasualConfiguration4());
var strict5 = new Chrono(createConfiguration4(true));
function parse5(text, ref, option) {
  return casual5.parse(text, ref, option);
}
function parseDate5(text, ref, option) {
  return casual5.parseDate(text, ref, option);
}
function createCasualConfiguration4(littleEndian = true) {
  const option = createConfiguration4(false, littleEndian);
  option.parsers.push(new PTCasualDateParser());
  option.parsers.push(new PTCasualTimeParser());
  return option;
}
function createConfiguration4(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new PTWeekdayParser(),
      new PTTimeExpressionParser(),
      new PTMonthNameLittleEndianParser()
    ],
    refiners: [new PTMergeDateTimeRefiner(), new PTMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/nl/index.js
var nl_exports = {};
__export(nl_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual6,
  createCasualConfiguration: () => createCasualConfiguration5,
  createConfiguration: () => createConfiguration5,
  parse: () => parse6,
  parseDate: () => parseDate6,
  strict: () => strict6
});

// node_modules/chrono-node/dist/esm/locales/nl/refiners/NLMergeDateRangeRefiner.js
var NLMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(tot|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/refiners/NLMergeDateTimeRefiner.js
var NLMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(om|na|voor|in de|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualDateParser.js
var NLCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(nu|vandaag|morgen|morgend|gisteren)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "nu":
        return now(context.reference);
      case "vandaag":
        return today(context.reference);
      case "morgen":
      case "morgend":
        return tomorrow(context.reference);
      case "gisteren":
        return yesterday(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualTimeParser.js
var import_dayjs21 = __toESM(require_dayjs_min(), 1);
var DAY_GROUP3 = 1;
var MOMENT_GROUP = 2;
var NLCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return /(deze)?\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const targetDate = (0, import_dayjs21.default)(context.refDate);
    const component = context.createParsingComponents();
    if (match[DAY_GROUP3] === "deze") {
      component.assign("day", context.refDate.getDate());
      component.assign("month", context.refDate.getMonth() + 1);
      component.assign("year", context.refDate.getFullYear());
    }
    switch (match[MOMENT_GROUP].toLowerCase()) {
      case "namiddag":
      case "'s namiddags":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "avond":
      case "'s avonds'":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 20);
        break;
      case "middernacht":
        assignTheNextDay(component, targetDate);
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        break;
      case "ochtend":
      case "'s ochtends":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "middag":
      case "'s middags":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/constants.js
var WEEKDAY_DICTIONARY5 = {
  zondag: 0,
  zon: 0,
  "zon.": 0,
  zo: 0,
  "zo.": 0,
  maandag: 1,
  ma: 1,
  "ma.": 1,
  dinsdag: 2,
  din: 2,
  "din.": 2,
  di: 2,
  "di.": 2,
  woensdag: 3,
  woe: 3,
  "woe.": 3,
  wo: 3,
  "wo.": 3,
  donderdag: 4,
  dond: 4,
  "dond.": 4,
  do: 4,
  "do.": 4,
  vrijdag: 5,
  vrij: 5,
  "vrij.": 5,
  vr: 5,
  "vr.": 5,
  zaterdag: 6,
  zat: 6,
  "zat.": 6,
  "za": 6,
  "za.": 6
};
var MONTH_DICTIONARY5 = {
  januari: 1,
  jan: 1,
  "jan.": 1,
  februari: 2,
  feb: 2,
  "feb.": 2,
  maart: 3,
  mar: 3,
  "mar.": 3,
  mrt: 3,
  "mrt.": 3,
  april: 4,
  apr: 4,
  "apr.": 4,
  mei: 5,
  juni: 6,
  jun: 6,
  "jun.": 6,
  juli: 7,
  jul: 7,
  "jul.": 7,
  augustus: 8,
  aug: 8,
  "aug.": 8,
  september: 9,
  sep: 9,
  "sep.": 9,
  sept: 9,
  "sept.": 9,
  oktober: 10,
  okt: 10,
  "okt.": 10,
  november: 11,
  nov: 11,
  "nov.": 11,
  december: 12,
  dec: 12,
  "dec.": 12
};
var INTEGER_WORD_DICTIONARY4 = {
  een: 1,
  twee: 2,
  drie: 3,
  vier: 4,
  vijf: 5,
  zes: 6,
  zeven: 7,
  acht: 8,
  negen: 9,
  tien: 10,
  elf: 11,
  twaalf: 12
};
var ORDINAL_WORD_DICTIONARY2 = {
  eerste: 1,
  tweede: 2,
  derde: 3,
  vierde: 4,
  vijfde: 5,
  zesde: 6,
  zevende: 7,
  achtste: 8,
  negende: 9,
  tiende: 10,
  elfde: 11,
  twaalfde: 12,
  dertiende: 13,
  veertiende: 14,
  vijftiende: 15,
  zestiende: 16,
  zeventiende: 17,
  achttiende: 18,
  negentiende: 19,
  twintigste: 20,
  "eenentwintigste": 21,
  "tweeÃ«ntwintigste": 22,
  "drieentwintigste": 23,
  "vierentwintigste": 24,
  "vijfentwintigste": 25,
  "zesentwintigste": 26,
  "zevenentwintigste": 27,
  "achtentwintig": 28,
  "negenentwintig": 29,
  "dertigste": 30,
  "eenendertigste": 31
};
var TIME_UNIT_DICTIONARY4 = {
  sec: "second",
  second: "second",
  seconden: "second",
  min: "minute",
  mins: "minute",
  minute: "minute",
  minuut: "minute",
  minuten: "minute",
  minuutje: "minute",
  h: "hour",
  hr: "hour",
  hrs: "hour",
  uur: "hour",
  u: "hour",
  uren: "hour",
  dag: "d",
  dagen: "d",
  week: "week",
  weken: "week",
  maand: "month",
  maanden: "month",
  jaar: "year",
  jr: "year",
  jaren: "year"
};
var NUMBER_PATTERN4 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY4)}|[0-9]+|[0-9]+[\\.,][0-9]+|halve?|half|paar)`;
function parseNumberPattern4(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY4[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY4[num];
  } else if (num === "paar") {
    return 2;
  } else if (num === "half" || num.match(/halve?/)) {
    return 0.5;
  }
  return parseFloat(num.replace(",", "."));
}
var ORDINAL_NUMBER_PATTERN3 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY2)}|[0-9]{1,2}(?:ste|de)?)`;
function parseOrdinalNumberPattern3(match) {
  let num = match.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY2[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY2[num];
  }
  num = num.replace(/(?:ste|de)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN5 = `(?:[1-9][0-9]{0,3}\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;
function parseYear5(match) {
  if (/voor Christus/i.test(match)) {
    match = match.replace(/voor Christus/i, "");
    return -parseInt(match);
  }
  if (/na Christus/i.test(match)) {
    match = match.replace(/na Christus/i, "");
    return parseInt(match);
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN4 = `(${NUMBER_PATTERN4})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY4)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX4 = new RegExp(SINGLE_TIME_UNIT_PATTERN4, "i");
var TIME_UNITS_PATTERN4 = repeatedTimeunitPattern(`(?:(?:binnen|in)\\s*)?`, SINGLE_TIME_UNIT_PATTERN4);
function parseTimeUnits4(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX4.exec(remainingText);
  while (match) {
    collectDateTimeFragment4(fragments, match);
    remainingText = remainingText.substring(match[0].length);
    match = SINGLE_TIME_UNIT_REGEX4.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment4(fragments, match) {
  const num = parseNumberPattern4(match[1]);
  const unit = TIME_UNIT_DICTIONARY4[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitWithinFormatParser.js
var NLTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:binnen|in|binnen de|voor)\\s*(` + TIME_UNITS_PATTERN4 + `)(?=\\W|$)`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits4(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLWeekdayParser.js
var PATTERN27 = new RegExp(`(?:(?:\\,|\\(|\\ï¼ˆ)\\s*)?(?:op\\s*?)?(?:(deze|vorige|volgende)\\s*(?:week\\s*)?)?(${matchAnyPattern(WEEKDAY_DICTIONARY5)})(?=\\W|$)`, "i");
var PREFIX_GROUP5 = 1;
var WEEKDAY_GROUP5 = 2;
var POSTFIX_GROUP4 = 3;
var NLWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN27;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP5].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY5[dayOfWeek];
    const prefix = match[PREFIX_GROUP5];
    const postfix = match[POSTFIX_GROUP4];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "vorige") {
      modifier = "last";
    } else if (modifierWord == "volgende") {
      modifier = "next";
    } else if (modifierWord == "deze") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLMonthNameMiddleEndianParser.js
var PATTERN28 = new RegExp(`(?:on\\s*?)?(${ORDINAL_NUMBER_PATTERN3})(?:\\s*(?:tot|\\-|\\â€“|until|through|till|\\s)\\s*(${ORDINAL_NUMBER_PATTERN3}))?(?:-|/|\\s*(?:of)?\\s*)(` + matchAnyPattern(MONTH_DICTIONARY5) + `)(?:(?:-|/|,?\\s*)(${YEAR_PATTERN5}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var MONTH_NAME_GROUP8 = 3;
var DATE_GROUP7 = 1;
var DATE_TO_GROUP6 = 2;
var YEAR_GROUP11 = 4;
var NLMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN28;
  }
  innerExtract(context, match) {
    const month = MONTH_DICTIONARY5[match[MONTH_NAME_GROUP8].toLowerCase()];
    const day = parseOrdinalNumberPattern3(match[DATE_GROUP7]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP7].length;
      return null;
    }
    const components = context.createParsingComponents({
      day,
      month
    });
    if (match[YEAR_GROUP11]) {
      const year3 = parseYear5(match[YEAR_GROUP11]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      components.imply("year", year3);
    }
    if (!match[DATE_TO_GROUP6]) {
      return components;
    }
    const endDate = parseOrdinalNumberPattern3(match[DATE_TO_GROUP6]);
    const result = context.createParsingResult(match.index, match[0]);
    result.start = components;
    result.end = components.clone();
    result.end.assign("day", endDate);
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLMonthNameParser.js
var PATTERN29 = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY5)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN5})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
var MONTH_NAME_GROUP9 = 1;
var YEAR_GROUP12 = 2;
var NLMonthNameParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN29;
  }
  innerExtract(context, match) {
    const components = context.createParsingComponents();
    components.imply("day", 1);
    const monthName = match[MONTH_NAME_GROUP9];
    const month = MONTH_DICTIONARY5[monthName.toLowerCase()];
    components.assign("month", month);
    if (match[YEAR_GROUP12]) {
      const year3 = parseYear5(match[YEAR_GROUP12]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month);
      components.imply("year", year3);
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLSlashMonthFormatParser.js
var PATTERN30 = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
var MONTH_GROUP4 = 1;
var YEAR_GROUP13 = 2;
var NLSlashMonthFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN30;
  }
  innerExtract(context, match) {
    const year3 = parseInt(match[YEAR_GROUP13]);
    const month = parseInt(match[MONTH_GROUP4]);
    return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year3);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeExpressionParser.js
var NLTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:om)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\â€“|\\~|\\ã€œ|om|\\?)\\s*";
  }
  primarySuffix() {
    return "(?:\\s*(?:uur))?(?!/)(?=\\W|$)";
  }
  extractPrimaryTimeComponents(context, match) {
    if (match[0].match(/^\s*\d{4}\s*$/)) {
      return null;
    }
    return super.extractPrimaryTimeComponents(context, match);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualYearMonthDayParser.js
var PATTERN31 = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${matchAnyPattern(MONTH_DICTIONARY5)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
var YEAR_NUMBER_GROUP4 = 1;
var MONTH_NAME_GROUP10 = 2;
var MONTH_NUMBER_GROUP3 = 3;
var DATE_NUMBER_GROUP3 = 4;
var NLCasualYearMonthDayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN31;
  }
  innerExtract(context, match) {
    const month = match[MONTH_NUMBER_GROUP3] ? parseInt(match[MONTH_NUMBER_GROUP3]) : MONTH_DICTIONARY5[match[MONTH_NAME_GROUP10].toLowerCase()];
    if (month < 1 || month > 12) {
      return null;
    }
    const year3 = parseInt(match[YEAR_NUMBER_GROUP4]);
    const day = parseInt(match[DATE_NUMBER_GROUP3]);
    return {
      day,
      month,
      year: year3
    };
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualDateTimeParser.js
var import_dayjs24 = __toESM(require_dayjs_min(), 1);
var DATE_GROUP8 = 1;
var TIME_OF_DAY_GROUP = 2;
var NLCasualDateTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const dateText = match[DATE_GROUP8].toLowerCase();
    const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();
    const component = context.createParsingComponents();
    const targetDate = (0, import_dayjs24.default)(context.refDate);
    switch (dateText) {
      case "gisteren":
        assignSimilarDate2(component, targetDate.add(-1, "day"));
        break;
      case "van":
        assignSimilarDate2(component, targetDate);
        break;
      case "morgen":
        assignTheNextDay(component, targetDate);
        break;
    }
    switch (timeText) {
      case "ochtend":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "middag":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
      case "namiddag":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "avond":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 20);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js
var PATTERN32 = new RegExp(`(dit|deze|vorig|afgelopen|(?:aan)?komend|over|\\+|-)e?\\s*(${TIME_UNITS_PATTERN4})(?=\\W|$)`, "i");
var PREFIX_WORD_GROUP = 1;
var TIME_UNIT_WORD_GROUP = 2;
var NLTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN32;
  }
  innerExtract(context, match) {
    const prefix = match[PREFIX_WORD_GROUP].toLowerCase();
    let timeUnits = parseTimeUnits4(match[TIME_UNIT_WORD_GROUP]);
    switch (prefix) {
      case "vorig":
      case "afgelopen":
      case "-":
        timeUnits = reverseTimeUnits(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLRelativeDateFormatParser.js
var import_dayjs25 = __toESM(require_dayjs_min(), 1);
var PATTERN33 = new RegExp(`(dit|deze|(?:aan)?komend|volgend|afgelopen|vorig)e?\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY4)})(?=\\s*)(?=\\W|$)`, "i");
var MODIFIER_WORD_GROUP2 = 1;
var RELATIVE_WORD_GROUP2 = 2;
var NLRelativeDateFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN33;
  }
  innerExtract(context, match) {
    const modifier = match[MODIFIER_WORD_GROUP2].toLowerCase();
    const unitWord = match[RELATIVE_WORD_GROUP2].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY4[unitWord];
    if (modifier == "volgend" || modifier == "komend" || modifier == "aankomend") {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "afgelopen" || modifier == "vorig") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = (0, import_dayjs25.default)(context.reference.instant);
    if (unitWord.match(/week/i)) {
      date = date.add(-date.get("d"), "d");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.imply("year", date.year());
    } else if (unitWord.match(/maand/i)) {
      date = date.add(-date.date() + 1, "d");
      components.imply("day", date.date());
      components.assign("year", date.year());
      components.assign("month", date.month() + 1);
    } else if (unitWord.match(/jaar/i)) {
      date = date.add(-date.date() + 1, "d");
      date = date.add(-date.month(), "month");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.assign("year", date.year());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitAgoFormatParser.js
var PATTERN34 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")(?:geleden|voor|eerder)(?=(?:\\W|$))", "i");
var STRICT_PATTERN3 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")geleden(?=(?:\\W|$))", "i");
var NLTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  strictMode;
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN3 : PATTERN34;
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits4(match[1]);
    const outputTimeUnits = reverseTimeUnits(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitLaterFormatParser.js
var PATTERN35 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")(later|na|vanaf nu|voortaan|vooruit|uit)(?=(?:\\W|$))", "i");
var STRICT_PATTERN4 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")(later|vanaf nu)(?=(?:\\W|$))", "i");
var GROUP_NUM_TIMEUNITS2 = 1;
var NLTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  strictMode;
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN4 : PATTERN35;
  }
  innerExtract(context, match) {
    const fragments = parseTimeUnits4(match[GROUP_NUM_TIMEUNITS2]);
    return ParsingComponents.createRelativeFromReference(context.reference, fragments);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/index.js
var casual6 = new Chrono(createCasualConfiguration5());
var strict6 = new Chrono(createConfiguration5(true));
function parse6(text, ref, option) {
  return casual6.parse(text, ref, option);
}
function parseDate6(text, ref, option) {
  return casual6.parseDate(text, ref, option);
}
function createCasualConfiguration5(littleEndian = true) {
  const option = createConfiguration5(false, littleEndian);
  option.parsers.unshift(new NLCasualDateParser());
  option.parsers.unshift(new NLCasualTimeParser());
  option.parsers.unshift(new NLCasualDateTimeParser());
  option.parsers.unshift(new NLMonthNameParser());
  option.parsers.unshift(new NLRelativeDateFormatParser());
  option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser());
  return option;
}
function createConfiguration5(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new NLTimeUnitWithinFormatParser(),
      new NLMonthNameMiddleEndianParser(),
      new NLMonthNameParser(),
      new NLWeekdayParser(),
      new NLCasualYearMonthDayParser(),
      new NLSlashMonthFormatParser(),
      new NLTimeExpressionParser(strictMode),
      new NLTimeUnitAgoFormatParser(strictMode),
      new NLTimeUnitLaterFormatParser(strictMode)
    ],
    refiners: [new NLMergeDateTimeRefiner(), new NLMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/zh/index.js
var zh_exports = {};
__export(zh_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual9,
  createCasualConfiguration: () => createCasualConfiguration8,
  createConfiguration: () => createConfiguration8,
  hans: () => hans_exports,
  hant: () => hant_exports,
  parse: () => parse9,
  parseDate: () => parseDate9,
  strict: () => strict9
});

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansDateParser.js
var import_dayjs26 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/locales/zh/hans/constants.js
var NUMBER2 = {
  "é›¶": 0,
  "ã€‡": 0,
  "ä¸€": 1,
  "äºŒ": 2,
  "ä¸¤": 2,
  "ä¸‰": 3,
  "å››": 4,
  "äº”": 5,
  "å…­": 6,
  "ä¸ƒ": 7,
  "å…«": 8,
  "ä¹": 9,
  "å": 10
};
var WEEKDAY_OFFSET2 = {
  "å¤©": 0,
  "æ—¥": 0,
  "ä¸€": 1,
  "äºŒ": 2,
  "ä¸‰": 3,
  "å››": 4,
  "äº”": 5,
  "å…­": 6
};
function zhStringToNumber(text) {
  let number = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (char === "å") {
      number = number === 0 ? NUMBER2[char] : number * NUMBER2[char];
    } else {
      number += NUMBER2[char];
    }
  }
  return number;
}
function zhStringToYear(text) {
  let string = "";
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    string = string + NUMBER2[char];
  }
  return parseInt(string);
}

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansDateParser.js
var YEAR_GROUP14 = 1;
var MONTH_GROUP5 = 2;
var DAY_GROUP4 = 3;
var ZHHansDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp("(\\d{2,4}|[" + Object.keys(NUMBER2).join("") + "]{4}|[" + Object.keys(NUMBER2).join("") + "]{2})?(?:\\s*)(?:å¹´)?(?:[\\s|,|ï¼Œ]*)(\\d{1,2}|[" + Object.keys(NUMBER2).join("") + "]{1,3})(?:\\s*)(?:æœˆ)(?:\\s*)(\\d{1,2}|[" + Object.keys(NUMBER2).join("") + "]{1,3})?(?:\\s*)(?:æ—¥|å·)?");
  }
  innerExtract(context, match) {
    const startMoment = (0, import_dayjs26.default)(context.refDate);
    const result = context.createParsingResult(match.index, match[0]);
    let month = parseInt(match[MONTH_GROUP5]);
    if (isNaN(month))
      month = zhStringToNumber(match[MONTH_GROUP5]);
    result.start.assign("month", month);
    if (match[DAY_GROUP4]) {
      let day = parseInt(match[DAY_GROUP4]);
      if (isNaN(day))
        day = zhStringToNumber(match[DAY_GROUP4]);
      result.start.assign("day", day);
    } else {
      result.start.imply("day", startMoment.date());
    }
    if (match[YEAR_GROUP14]) {
      let year3 = parseInt(match[YEAR_GROUP14]);
      if (isNaN(year3))
        year3 = zhStringToYear(match[YEAR_GROUP14]);
      result.start.assign("year", year3);
    } else {
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js
var import_dayjs27 = __toESM(require_dayjs_min(), 1);
var PATTERN36 = new RegExp("(\\d+|[" + Object.keys(NUMBER2).join("") + "]+|åŠ|å‡ )(?:\\s*)(?:ä¸ª)?(ç§’(?:é’Ÿ)?|åˆ†é’Ÿ|å°æ—¶|é’Ÿ|æ—¥|å¤©|æ˜ŸæœŸ|ç¤¼æ‹œ|æœˆ|å¹´)(?:(?:ä¹‹|è¿‡)?åŽ|(?:ä¹‹)?å†…)", "i");
var NUMBER_GROUP = 1;
var UNIT_GROUP = 2;
var ZHHansDeadlineFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN36;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    let number = parseInt(match[NUMBER_GROUP]);
    if (isNaN(number)) {
      number = zhStringToNumber(match[NUMBER_GROUP]);
    }
    if (isNaN(number)) {
      const string = match[NUMBER_GROUP];
      if (string === "å‡ ") {
        number = 3;
      } else if (string === "åŠ") {
        number = 0.5;
      } else {
        return null;
      }
    }
    let date = (0, import_dayjs27.default)(context.refDate);
    const unit = match[UNIT_GROUP];
    const unitAbbr = unit[0];
    if (unitAbbr.match(/[æ—¥å¤©æ˜Ÿç¤¼æœˆå¹´]/)) {
      if (unitAbbr == "æ—¥" || unitAbbr == "å¤©") {
        date = date.add(number, "d");
      } else if (unitAbbr == "æ˜Ÿ" || unitAbbr == "ç¤¼") {
        date = date.add(number * 7, "d");
      } else if (unitAbbr == "æœˆ") {
        date = date.add(number, "month");
      } else if (unitAbbr == "å¹´") {
        date = date.add(number, "year");
      }
      result.start.assign("year", date.year());
      result.start.assign("month", date.month() + 1);
      result.start.assign("day", date.date());
      return result;
    }
    if (unitAbbr == "ç§’") {
      date = date.add(number, "second");
    } else if (unitAbbr == "åˆ†") {
      date = date.add(number, "minute");
    } else if (unitAbbr == "å°" || unitAbbr == "é’Ÿ") {
      date = date.add(number, "hour");
    }
    result.start.imply("year", date.year());
    result.start.imply("month", date.month() + 1);
    result.start.imply("day", date.date());
    result.start.assign("hour", date.hour());
    result.start.assign("minute", date.minute());
    result.start.assign("second", date.second());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js
var import_dayjs28 = __toESM(require_dayjs_min(), 1);
var PATTERN37 = new RegExp("(?<prefix>ä¸Š|ä¸‹|è¿™)(?:ä¸ª)?(?:æ˜ŸæœŸ|ç¤¼æ‹œ|å‘¨)(?<weekday>" + Object.keys(WEEKDAY_OFFSET2).join("|") + ")");
var ZHHansRelationWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN37;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET2[dayOfWeek];
    if (offset === void 0)
      return null;
    let modifier = null;
    const prefix = match.groups.prefix;
    if (prefix == "ä¸Š") {
      modifier = "last";
    } else if (prefix == "ä¸‹") {
      modifier = "next";
    } else if (prefix == "è¿™") {
      modifier = "this";
    }
    let startMoment = (0, import_dayjs28.default)(context.refDate);
    let startMomentFixed = false;
    const refOffset = startMoment.day();
    if (modifier == "last" || modifier == "past") {
      startMoment = startMoment.day(offset - 7);
      startMomentFixed = true;
    } else if (modifier == "next") {
      startMoment = startMoment.day(offset + 7);
      startMomentFixed = true;
    } else if (modifier == "this") {
      startMoment = startMoment.day(offset);
    } else {
      if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
        startMoment = startMoment.day(offset - 7);
      } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
        startMoment = startMoment.day(offset + 7);
      } else {
        startMoment = startMoment.day(offset);
      }
    }
    result.start.assign("weekday", offset);
    if (startMomentFixed) {
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js
var import_dayjs29 = __toESM(require_dayjs_min(), 1);
var FIRST_REG_PATTERN4 = new RegExp("(?:ä»Ž|è‡ª)?(?:(ä»Š|æ˜Ž|å‰|å¤§å‰|åŽ|å¤§åŽ|æ˜¨)(æ—©|æœ|æ™š)|(ä¸Š(?:åˆ)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨))|(ä»Š|æ˜Ž|å‰|å¤§å‰|åŽ|å¤§åŽ|æ˜¨)(?:æ—¥|å¤©)(?:[\\s,ï¼Œ]*)(?:(ä¸Š(?:åˆ)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨)))?)?(?:[\\s,ï¼Œ]*)(?:(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)(?:\\s*)(?:ç‚¹|æ—¶|:|ï¼š)(?:\\s*)(\\d+|åŠ|æ­£|æ•´|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:åˆ†|:|ï¼š)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:ç§’)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var SECOND_REG_PATTERN4 = new RegExp("(?:^\\s*(?:åˆ°|è‡³|\\-|\\â€“|\\~|\\ã€œ)\\s*)(?:(ä»Š|æ˜Ž|å‰|å¤§å‰|åŽ|å¤§åŽ|æ˜¨)(æ—©|æœ|æ™š)|(ä¸Š(?:åˆ)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨))|(ä»Š|æ˜Ž|å‰|å¤§å‰|åŽ|å¤§åŽ|æ˜¨)(?:æ—¥|å¤©)(?:[\\s,ï¼Œ]*)(?:(ä¸Š(?:åˆ)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨)))?)?(?:[\\s,ï¼Œ]*)(?:(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)(?:\\s*)(?:ç‚¹|æ—¶|:|ï¼š)(?:\\s*)(\\d+|åŠ|æ­£|æ•´|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:åˆ†|:|ï¼š)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:ç§’)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var DAY_GROUP_1 = 1;
var ZH_AM_PM_HOUR_GROUP_1 = 2;
var ZH_AM_PM_HOUR_GROUP_2 = 3;
var DAY_GROUP_3 = 4;
var ZH_AM_PM_HOUR_GROUP_3 = 5;
var HOUR_GROUP5 = 6;
var MINUTE_GROUP5 = 7;
var SECOND_GROUP5 = 8;
var AM_PM_HOUR_GROUP4 = 9;
var ZHHansTimeExpressionParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return FIRST_REG_PATTERN4;
  }
  innerExtract(context, match) {
    if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
      return null;
    }
    const refMoment = (0, import_dayjs29.default)(context.refDate);
    const result = context.createParsingResult(match.index, match[0]);
    let startMoment = refMoment.clone();
    if (match[DAY_GROUP_1]) {
      const day1 = match[DAY_GROUP_1];
      if (day1 == "æ˜Ž") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day1 == "æ˜¨") {
        startMoment = startMoment.add(-1, "day");
      } else if (day1 == "å‰") {
        startMoment = startMoment.add(-2, "day");
      } else if (day1 == "å¤§å‰") {
        startMoment = startMoment.add(-3, "day");
      } else if (day1 == "åŽ") {
        startMoment = startMoment.add(2, "day");
      } else if (day1 == "å¤§åŽ") {
        startMoment = startMoment.add(3, "day");
      }
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else if (match[DAY_GROUP_3]) {
      const day3 = match[DAY_GROUP_3];
      if (day3 == "æ˜Ž") {
        startMoment = startMoment.add(1, "day");
      } else if (day3 == "æ˜¨") {
        startMoment = startMoment.add(-1, "day");
      } else if (day3 == "å‰") {
        startMoment = startMoment.add(-2, "day");
      } else if (day3 == "å¤§å‰") {
        startMoment = startMoment.add(-3, "day");
      } else if (day3 == "åŽ") {
        startMoment = startMoment.add(2, "day");
      } else if (day3 == "å¤§åŽ") {
        startMoment = startMoment.add(3, "day");
      }
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    let hour = 0;
    let minute = 0;
    let meridiem = -1;
    if (match[SECOND_GROUP5]) {
      let second = parseInt(match[SECOND_GROUP5]);
      if (isNaN(second)) {
        second = zhStringToNumber(match[SECOND_GROUP5]);
      }
      if (second >= 60)
        return null;
      result.start.assign("second", second);
    }
    hour = parseInt(match[HOUR_GROUP5]);
    if (isNaN(hour)) {
      hour = zhStringToNumber(match[HOUR_GROUP5]);
    }
    if (match[MINUTE_GROUP5]) {
      if (match[MINUTE_GROUP5] == "åŠ") {
        minute = 30;
      } else if (match[MINUTE_GROUP5] == "æ­£" || match[MINUTE_GROUP5] == "æ•´") {
        minute = 0;
      } else {
        minute = parseInt(match[MINUTE_GROUP5]);
        if (isNaN(minute)) {
          minute = zhStringToNumber(match[MINUTE_GROUP5]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match[AM_PM_HOUR_GROUP4]) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP4][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
      const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
      const zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "æ—©") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
      const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
      const zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "ä¸Š" || zhAMPM2 == "æ—©" || zhAMPM2 == "å‡Œ") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "ä¸‹" || zhAMPM2 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
      const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
      const zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "ä¸Š" || zhAMPM3 == "æ—©" || zhAMPM3 == "å‡Œ") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "ä¸‹" || zhAMPM3 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.start.assign("hour", hour);
    result.start.assign("minute", minute);
    if (meridiem >= 0) {
      result.start.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        result.start.imply("meridiem", 0);
      } else {
        result.start.imply("meridiem", 1);
      }
    }
    match = SECOND_REG_PATTERN4.exec(context.text.substring(result.index + result.text.length));
    if (!match) {
      if (result.text.match(/^\d+$/)) {
        return null;
      }
      return result;
    }
    let endMoment = startMoment.clone();
    result.end = context.createParsingComponents();
    if (match[DAY_GROUP_1]) {
      const day1 = match[DAY_GROUP_1];
      if (day1 == "æ˜Ž") {
        if (refMoment.hour() > 1) {
          endMoment = endMoment.add(1, "day");
        }
      } else if (day1 == "æ˜¨") {
        endMoment = endMoment.add(-1, "day");
      } else if (day1 == "å‰") {
        endMoment = endMoment.add(-2, "day");
      } else if (day1 == "å¤§å‰") {
        endMoment = endMoment.add(-3, "day");
      } else if (day1 == "åŽ") {
        endMoment = endMoment.add(2, "day");
      } else if (day1 == "å¤§åŽ") {
        endMoment = endMoment.add(3, "day");
      }
      result.end.assign("day", endMoment.date());
      result.end.assign("month", endMoment.month() + 1);
      result.end.assign("year", endMoment.year());
    } else if (match[DAY_GROUP_3]) {
      const day3 = match[DAY_GROUP_3];
      if (day3 == "æ˜Ž") {
        endMoment = endMoment.add(1, "day");
      } else if (day3 == "æ˜¨") {
        endMoment = endMoment.add(-1, "day");
      } else if (day3 == "å‰") {
        endMoment = endMoment.add(-2, "day");
      } else if (day3 == "å¤§å‰") {
        endMoment = endMoment.add(-3, "day");
      } else if (day3 == "åŽ") {
        endMoment = endMoment.add(2, "day");
      } else if (day3 == "å¤§åŽ") {
        endMoment = endMoment.add(3, "day");
      }
      result.end.assign("day", endMoment.date());
      result.end.assign("month", endMoment.month() + 1);
      result.end.assign("year", endMoment.year());
    } else {
      result.end.imply("day", endMoment.date());
      result.end.imply("month", endMoment.month() + 1);
      result.end.imply("year", endMoment.year());
    }
    hour = 0;
    minute = 0;
    meridiem = -1;
    if (match[SECOND_GROUP5]) {
      let second = parseInt(match[SECOND_GROUP5]);
      if (isNaN(second)) {
        second = zhStringToNumber(match[SECOND_GROUP5]);
      }
      if (second >= 60)
        return null;
      result.end.assign("second", second);
    }
    hour = parseInt(match[HOUR_GROUP5]);
    if (isNaN(hour)) {
      hour = zhStringToNumber(match[HOUR_GROUP5]);
    }
    if (match[MINUTE_GROUP5]) {
      if (match[MINUTE_GROUP5] == "åŠ") {
        minute = 30;
      } else if (match[MINUTE_GROUP5] == "æ­£" || match[MINUTE_GROUP5] == "æ•´") {
        minute = 0;
      } else {
        minute = parseInt(match[MINUTE_GROUP5]);
        if (isNaN(minute)) {
          minute = zhStringToNumber(match[MINUTE_GROUP5]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match[AM_PM_HOUR_GROUP4]) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP4][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem == 0) {
          result.start.imply("meridiem", 0);
          if (result.start.get("hour") == 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", 1);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
      const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
      const zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "æ—©") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
      const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
      const zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "ä¸Š" || zhAMPM2 == "æ—©" || zhAMPM2 == "å‡Œ") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "ä¸‹" || zhAMPM2 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
      const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
      const zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "ä¸Š" || zhAMPM3 == "æ—©" || zhAMPM3 == "å‡Œ") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "ä¸‹" || zhAMPM3 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.text = result.text + match[0];
    result.end.assign("hour", hour);
    result.end.assign("minute", minute);
    if (meridiem >= 0) {
      result.end.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
      if (startAtPM && result.start.get("hour") > hour) {
        result.end.imply("meridiem", 0);
      } else if (hour > 12) {
        result.end.imply("meridiem", 1);
      }
    }
    if (result.end.date().getTime() < result.start.date().getTime()) {
      result.end.imply("day", result.end.get("day") + 1);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansWeekdayParser.js
var import_dayjs30 = __toESM(require_dayjs_min(), 1);
var PATTERN38 = new RegExp("(?:æ˜ŸæœŸ|ç¤¼æ‹œ|å‘¨)(?<weekday>" + Object.keys(WEEKDAY_OFFSET2).join("|") + ")");
var ZHHansWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN38;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET2[dayOfWeek];
    if (offset === void 0)
      return null;
    let startMoment = (0, import_dayjs30.default)(context.refDate);
    const startMomentFixed = false;
    const refOffset = startMoment.day();
    if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
      startMoment = startMoment.day(offset - 7);
    } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
      startMoment = startMoment.day(offset + 7);
    } else {
      startMoment = startMoment.day(offset);
    }
    result.start.assign("weekday", offset);
    if (startMomentFixed) {
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantCasualDateParser.js
var import_dayjs31 = __toESM(require_dayjs_min(), 1);
var NOW_GROUP = 1;
var DAY_GROUP_12 = 2;
var TIME_GROUP_1 = 3;
var TIME_GROUP_2 = 4;
var DAY_GROUP_32 = 5;
var TIME_GROUP_3 = 6;
var ZHHantCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return new RegExp("(è€Œå®¶|ç«‹(?:åˆ»|å³)|å³åˆ»)|(ä»Š|æ˜Ž|å‰|å¤§å‰|å¾Œ|å¤§å¾Œ|è½|æ˜¨|å°‹|ç´)(æ—©|æœ|æ™š)|(ä¸Š(?:åˆ|æ™)|æœ(?:æ—©)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ|æ™)|æ™(?:æ™)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨))|(ä»Š|æ˜Ž|å‰|å¤§å‰|å¾Œ|å¤§å¾Œ|è½|æ˜¨|å°‹|ç´)(?:æ—¥|å¤©)(?:[\\s|,|ï¼Œ]*)(?:(ä¸Š(?:åˆ|æ™)|æœ(?:æ—©)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ|æ™)|æ™(?:æ™)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨)))?", "i");
  }
  innerExtract(context, match) {
    const index = match.index;
    const result = context.createParsingResult(index, match[0]);
    const refMoment = (0, import_dayjs31.default)(context.refDate);
    let startMoment = refMoment;
    if (match[NOW_GROUP]) {
      result.start.imply("hour", refMoment.hour());
      result.start.imply("minute", refMoment.minute());
      result.start.imply("second", refMoment.second());
      result.start.imply("millisecond", refMoment.millisecond());
    } else if (match[DAY_GROUP_12]) {
      const day1 = match[DAY_GROUP_12];
      const time1 = match[TIME_GROUP_1];
      if (day1 == "æ˜Ž" || day1 == "è½") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day1 == "æ˜¨" || day1 == "å°‹" || day1 == "ç´") {
        startMoment = startMoment.add(-1, "day");
      } else if (day1 == "å‰") {
        startMoment = startMoment.add(-2, "day");
      } else if (day1 == "å¤§å‰") {
        startMoment = startMoment.add(-3, "day");
      } else if (day1 == "å¾Œ") {
        startMoment = startMoment.add(2, "day");
      } else if (day1 == "å¤§å¾Œ") {
        startMoment = startMoment.add(3, "day");
      }
      if (time1 == "æ—©" || time1 == "æœ") {
        result.start.imply("hour", 6);
      } else if (time1 == "æ™š") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      }
    } else if (match[TIME_GROUP_2]) {
      const timeString2 = match[TIME_GROUP_2];
      const time2 = timeString2[0];
      if (time2 == "æ—©" || time2 == "æœ" || time2 == "ä¸Š") {
        result.start.imply("hour", 6);
      } else if (time2 == "ä¸‹" || time2 == "æ™") {
        result.start.imply("hour", 15);
        result.start.imply("meridiem", 1);
      } else if (time2 == "ä¸­") {
        result.start.imply("hour", 12);
        result.start.imply("meridiem", 1);
      } else if (time2 == "å¤œ" || time2 == "æ™š") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      } else if (time2 == "å‡Œ") {
        result.start.imply("hour", 0);
      }
    } else if (match[DAY_GROUP_32]) {
      const day3 = match[DAY_GROUP_32];
      if (day3 == "æ˜Ž" || day3 == "è½") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day3 == "æ˜¨" || day3 == "å°‹" || day3 == "ç´") {
        startMoment = startMoment.add(-1, "day");
      } else if (day3 == "å‰") {
        startMoment = startMoment.add(-2, "day");
      } else if (day3 == "å¤§å‰") {
        startMoment = startMoment.add(-3, "day");
      } else if (day3 == "å¾Œ") {
        startMoment = startMoment.add(2, "day");
      } else if (day3 == "å¤§å¾Œ") {
        startMoment = startMoment.add(3, "day");
      }
      const timeString3 = match[TIME_GROUP_3];
      if (timeString3) {
        const time3 = timeString3[0];
        if (time3 == "æ—©" || time3 == "æœ" || time3 == "ä¸Š") {
          result.start.imply("hour", 6);
        } else if (time3 == "ä¸‹" || time3 == "æ™") {
          result.start.imply("hour", 15);
          result.start.imply("meridiem", 1);
        } else if (time3 == "ä¸­") {
          result.start.imply("hour", 12);
          result.start.imply("meridiem", 1);
        } else if (time3 == "å¤œ" || time3 == "æ™š") {
          result.start.imply("hour", 22);
          result.start.imply("meridiem", 1);
        } else if (time3 == "å‡Œ") {
          result.start.imply("hour", 0);
        }
      }
    }
    result.start.assign("day", startMoment.date());
    result.start.assign("month", startMoment.month() + 1);
    result.start.assign("year", startMoment.year());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantDateParser.js
var import_dayjs32 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/locales/zh/hant/constants.js
var NUMBER3 = {
  "é›¶": 0,
  "ä¸€": 1,
  "äºŒ": 2,
  "å…©": 2,
  "ä¸‰": 3,
  "å››": 4,
  "äº”": 5,
  "å…­": 6,
  "ä¸ƒ": 7,
  "å…«": 8,
  "ä¹": 9,
  "å": 10,
  "å»¿": 20,
  "å…": 30
};
var WEEKDAY_OFFSET3 = {
  "å¤©": 0,
  "æ—¥": 0,
  "ä¸€": 1,
  "äºŒ": 2,
  "ä¸‰": 3,
  "å››": 4,
  "äº”": 5,
  "å…­": 6
};
function zhStringToNumber2(text) {
  let number = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (char === "å") {
      number = number === 0 ? NUMBER3[char] : number * NUMBER3[char];
    } else {
      number += NUMBER3[char];
    }
  }
  return number;
}
function zhStringToYear2(text) {
  let string = "";
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    string = string + NUMBER3[char];
  }
  return parseInt(string);
}

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantDateParser.js
var YEAR_GROUP15 = 1;
var MONTH_GROUP6 = 2;
var DAY_GROUP5 = 3;
var ZHHantDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp("(\\d{2,4}|[" + Object.keys(NUMBER3).join("") + "]{4}|[" + Object.keys(NUMBER3).join("") + "]{2})?(?:\\s*)(?:å¹´)?(?:[\\s|,|ï¼Œ]*)(\\d{1,2}|[" + Object.keys(NUMBER3).join("") + "]{1,2})(?:\\s*)(?:æœˆ)(?:\\s*)(\\d{1,2}|[" + Object.keys(NUMBER3).join("") + "]{1,2})?(?:\\s*)(?:æ—¥|è™Ÿ)?");
  }
  innerExtract(context, match) {
    const startMoment = (0, import_dayjs32.default)(context.refDate);
    const result = context.createParsingResult(match.index, match[0]);
    let month = parseInt(match[MONTH_GROUP6]);
    if (isNaN(month))
      month = zhStringToNumber2(match[MONTH_GROUP6]);
    result.start.assign("month", month);
    if (match[DAY_GROUP5]) {
      let day = parseInt(match[DAY_GROUP5]);
      if (isNaN(day))
        day = zhStringToNumber2(match[DAY_GROUP5]);
      result.start.assign("day", day);
    } else {
      result.start.imply("day", startMoment.date());
    }
    if (match[YEAR_GROUP15]) {
      let year3 = parseInt(match[YEAR_GROUP15]);
      if (isNaN(year3))
        year3 = zhStringToYear2(match[YEAR_GROUP15]);
      result.start.assign("year", year3);
    } else {
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js
var import_dayjs33 = __toESM(require_dayjs_min(), 1);
var PATTERN39 = new RegExp("(\\d+|[" + Object.keys(NUMBER3).join("") + "]+|åŠ|å¹¾)(?:\\s*)(?:å€‹)?(ç§’(?:é˜)?|åˆ†é˜|å°æ™‚|é˜|æ—¥|å¤©|æ˜ŸæœŸ|ç¦®æ‹œ|æœˆ|å¹´)(?:(?:ä¹‹|éŽ)?å¾Œ|(?:ä¹‹)?å…§)", "i");
var NUMBER_GROUP2 = 1;
var UNIT_GROUP2 = 2;
var ZHHantDeadlineFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN39;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    let number = parseInt(match[NUMBER_GROUP2]);
    if (isNaN(number)) {
      number = zhStringToNumber2(match[NUMBER_GROUP2]);
    }
    if (isNaN(number)) {
      const string = match[NUMBER_GROUP2];
      if (string === "å¹¾") {
        number = 3;
      } else if (string === "åŠ") {
        number = 0.5;
      } else {
        return null;
      }
    }
    let date = (0, import_dayjs33.default)(context.refDate);
    const unit = match[UNIT_GROUP2];
    const unitAbbr = unit[0];
    if (unitAbbr.match(/[æ—¥å¤©æ˜Ÿç¦®æœˆå¹´]/)) {
      if (unitAbbr == "æ—¥" || unitAbbr == "å¤©") {
        date = date.add(number, "d");
      } else if (unitAbbr == "æ˜Ÿ" || unitAbbr == "ç¦®") {
        date = date.add(number * 7, "d");
      } else if (unitAbbr == "æœˆ") {
        date = date.add(number, "month");
      } else if (unitAbbr == "å¹´") {
        date = date.add(number, "year");
      }
      result.start.assign("year", date.year());
      result.start.assign("month", date.month() + 1);
      result.start.assign("day", date.date());
      return result;
    }
    if (unitAbbr == "ç§’") {
      date = date.add(number, "second");
    } else if (unitAbbr == "åˆ†") {
      date = date.add(number, "minute");
    } else if (unitAbbr == "å°" || unitAbbr == "é˜") {
      date = date.add(number, "hour");
    }
    result.start.imply("year", date.year());
    result.start.imply("month", date.month() + 1);
    result.start.imply("day", date.date());
    result.start.assign("hour", date.hour());
    result.start.assign("minute", date.minute());
    result.start.assign("second", date.second());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js
var import_dayjs34 = __toESM(require_dayjs_min(), 1);
var PATTERN40 = new RegExp("(?<prefix>ä¸Š|ä»Š|ä¸‹|é€™|å‘¢)(?:å€‹)?(?:æ˜ŸæœŸ|ç¦®æ‹œ|é€±)(?<weekday>" + Object.keys(WEEKDAY_OFFSET3).join("|") + ")");
var ZHHantRelationWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN40;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET3[dayOfWeek];
    if (offset === void 0)
      return null;
    let modifier = null;
    const prefix = match.groups.prefix;
    if (prefix == "ä¸Š") {
      modifier = "last";
    } else if (prefix == "ä¸‹") {
      modifier = "next";
    } else if (prefix == "ä»Š" || prefix == "é€™" || prefix == "å‘¢") {
      modifier = "this";
    }
    let startMoment = (0, import_dayjs34.default)(context.refDate);
    let startMomentFixed = false;
    const refOffset = startMoment.day();
    if (modifier == "last" || modifier == "past") {
      startMoment = startMoment.day(offset - 7);
      startMomentFixed = true;
    } else if (modifier == "next") {
      startMoment = startMoment.day(offset + 7);
      startMomentFixed = true;
    } else if (modifier == "this") {
      startMoment = startMoment.day(offset);
    } else {
      if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
        startMoment = startMoment.day(offset - 7);
      } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
        startMoment = startMoment.day(offset + 7);
      } else {
        startMoment = startMoment.day(offset);
      }
    }
    result.start.assign("weekday", offset);
    if (startMomentFixed) {
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js
var import_dayjs35 = __toESM(require_dayjs_min(), 1);
var FIRST_REG_PATTERN5 = new RegExp("(?:ç”±|å¾ž|è‡ª)?(?:(ä»Š|æ˜Ž|å‰|å¤§å‰|å¾Œ|å¤§å¾Œ|è½|æ˜¨|å°‹|ç´)(æ—©|æœ|æ™š)|(ä¸Š(?:åˆ|æ™)|æœ(?:æ—©)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ|æ™)|æ™(?:æ™)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨))|(ä»Š|æ˜Ž|å‰|å¤§å‰|å¾Œ|å¤§å¾Œ|è½|æ˜¨|å°‹|ç´)(?:æ—¥|å¤©)(?:[\\s,ï¼Œ]*)(?:(ä¸Š(?:åˆ|æ™)|æœ(?:æ—©)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ|æ™)|æ™(?:æ™)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨)))?)?(?:[\\s,ï¼Œ]*)(?:(\\d+|[" + Object.keys(NUMBER3).join("") + "]+)(?:\\s*)(?:é»ž|æ™‚|:|ï¼š)(?:\\s*)(\\d+|åŠ|æ­£|æ•´|[" + Object.keys(NUMBER3).join("") + "]+)?(?:\\s*)(?:åˆ†|:|ï¼š)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER3).join("") + "]+)?(?:\\s*)(?:ç§’)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var SECOND_REG_PATTERN5 = new RegExp("(?:^\\s*(?:åˆ°|è‡³|\\-|\\â€“|\\~|\\ã€œ)\\s*)(?:(ä»Š|æ˜Ž|å‰|å¤§å‰|å¾Œ|å¤§å¾Œ|è½|æ˜¨|å°‹|ç´)(æ—©|æœ|æ™š)|(ä¸Š(?:åˆ|æ™)|æœ(?:æ—©)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ|æ™)|æ™(?:æ™)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨))|(ä»Š|æ˜Ž|å‰|å¤§å‰|å¾Œ|å¤§å¾Œ|è½|æ˜¨|å°‹|ç´)(?:æ—¥|å¤©)(?:[\\s,ï¼Œ]*)(?:(ä¸Š(?:åˆ|æ™)|æœ(?:æ—©)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ|æ™)|æ™(?:æ™)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨)))?)?(?:[\\s,ï¼Œ]*)(?:(\\d+|[" + Object.keys(NUMBER3).join("") + "]+)(?:\\s*)(?:é»ž|æ™‚|:|ï¼š)(?:\\s*)(\\d+|åŠ|æ­£|æ•´|[" + Object.keys(NUMBER3).join("") + "]+)?(?:\\s*)(?:åˆ†|:|ï¼š)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER3).join("") + "]+)?(?:\\s*)(?:ç§’)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var DAY_GROUP_13 = 1;
var ZH_AM_PM_HOUR_GROUP_12 = 2;
var ZH_AM_PM_HOUR_GROUP_22 = 3;
var DAY_GROUP_33 = 4;
var ZH_AM_PM_HOUR_GROUP_32 = 5;
var HOUR_GROUP6 = 6;
var MINUTE_GROUP6 = 7;
var SECOND_GROUP6 = 8;
var AM_PM_HOUR_GROUP5 = 9;
var ZHHantTimeExpressionParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return FIRST_REG_PATTERN5;
  }
  innerExtract(context, match) {
    if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
      return null;
    }
    const refMoment = (0, import_dayjs35.default)(context.refDate);
    const result = context.createParsingResult(match.index, match[0]);
    let startMoment = refMoment.clone();
    if (match[DAY_GROUP_13]) {
      var day1 = match[DAY_GROUP_13];
      if (day1 == "æ˜Ž" || day1 == "è½") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day1 == "æ˜¨" || day1 == "å°‹" || day1 == "ç´") {
        startMoment = startMoment.add(-1, "day");
      } else if (day1 == "å‰") {
        startMoment = startMoment.add(-2, "day");
      } else if (day1 == "å¤§å‰") {
        startMoment = startMoment.add(-3, "day");
      } else if (day1 == "å¾Œ") {
        startMoment = startMoment.add(2, "day");
      } else if (day1 == "å¤§å¾Œ") {
        startMoment = startMoment.add(3, "day");
      }
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else if (match[DAY_GROUP_33]) {
      var day3 = match[DAY_GROUP_33];
      if (day3 == "æ˜Ž" || day3 == "è½") {
        startMoment = startMoment.add(1, "day");
      } else if (day3 == "æ˜¨" || day3 == "å°‹" || day3 == "ç´") {
        startMoment = startMoment.add(-1, "day");
      } else if (day3 == "å‰") {
        startMoment = startMoment.add(-2, "day");
      } else if (day3 == "å¤§å‰") {
        startMoment = startMoment.add(-3, "day");
      } else if (day3 == "å¾Œ") {
        startMoment = startMoment.add(2, "day");
      } else if (day3 == "å¤§å¾Œ") {
        startMoment = startMoment.add(3, "day");
      }
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    let hour = 0;
    let minute = 0;
    let meridiem = -1;
    if (match[SECOND_GROUP6]) {
      var second = parseInt(match[SECOND_GROUP6]);
      if (isNaN(second)) {
        second = zhStringToNumber2(match[SECOND_GROUP6]);
      }
      if (second >= 60)
        return null;
      result.start.assign("second", second);
    }
    hour = parseInt(match[HOUR_GROUP6]);
    if (isNaN(hour)) {
      hour = zhStringToNumber2(match[HOUR_GROUP6]);
    }
    if (match[MINUTE_GROUP6]) {
      if (match[MINUTE_GROUP6] == "åŠ") {
        minute = 30;
      } else if (match[MINUTE_GROUP6] == "æ­£" || match[MINUTE_GROUP6] == "æ•´") {
        minute = 0;
      } else {
        minute = parseInt(match[MINUTE_GROUP6]);
        if (isNaN(minute)) {
          minute = zhStringToNumber2(match[MINUTE_GROUP6]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match[AM_PM_HOUR_GROUP5]) {
      if (hour > 12)
        return null;
      var ampm = match[AM_PM_HOUR_GROUP5][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_12]) {
      var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_12];
      var zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "æœ" || zhAMPM1 == "æ—©") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_22]) {
      var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_22];
      var zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "ä¸Š" || zhAMPM2 == "æœ" || zhAMPM2 == "æ—©" || zhAMPM2 == "å‡Œ") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "ä¸‹" || zhAMPM2 == "æ™" || zhAMPM2 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_32]) {
      var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_32];
      var zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "ä¸Š" || zhAMPM3 == "æœ" || zhAMPM3 == "æ—©" || zhAMPM3 == "å‡Œ") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "ä¸‹" || zhAMPM3 == "æ™" || zhAMPM3 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.start.assign("hour", hour);
    result.start.assign("minute", minute);
    if (meridiem >= 0) {
      result.start.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        result.start.imply("meridiem", 0);
      } else {
        result.start.imply("meridiem", 1);
      }
    }
    match = SECOND_REG_PATTERN5.exec(context.text.substring(result.index + result.text.length));
    if (!match) {
      if (result.text.match(/^\d+$/)) {
        return null;
      }
      return result;
    }
    let endMoment = startMoment.clone();
    result.end = context.createParsingComponents();
    if (match[DAY_GROUP_13]) {
      var day1 = match[DAY_GROUP_13];
      if (day1 == "æ˜Ž" || day1 == "è½") {
        if (refMoment.hour() > 1) {
          endMoment = endMoment.add(1, "day");
        }
      } else if (day1 == "æ˜¨" || day1 == "å°‹" || day1 == "ç´") {
        endMoment = endMoment.add(-1, "day");
      } else if (day1 == "å‰") {
        endMoment = endMoment.add(-2, "day");
      } else if (day1 == "å¤§å‰") {
        endMoment = endMoment.add(-3, "day");
      } else if (day1 == "å¾Œ") {
        endMoment = endMoment.add(2, "day");
      } else if (day1 == "å¤§å¾Œ") {
        endMoment = endMoment.add(3, "day");
      }
      result.end.assign("day", endMoment.date());
      result.end.assign("month", endMoment.month() + 1);
      result.end.assign("year", endMoment.year());
    } else if (match[DAY_GROUP_33]) {
      var day3 = match[DAY_GROUP_33];
      if (day3 == "æ˜Ž" || day3 == "è½") {
        endMoment = endMoment.add(1, "day");
      } else if (day3 == "æ˜¨" || day3 == "å°‹" || day3 == "ç´") {
        endMoment = endMoment.add(-1, "day");
      } else if (day3 == "å‰") {
        endMoment = endMoment.add(-2, "day");
      } else if (day3 == "å¤§å‰") {
        endMoment = endMoment.add(-3, "day");
      } else if (day3 == "å¾Œ") {
        endMoment = endMoment.add(2, "day");
      } else if (day3 == "å¤§å¾Œ") {
        endMoment = endMoment.add(3, "day");
      }
      result.end.assign("day", endMoment.date());
      result.end.assign("month", endMoment.month() + 1);
      result.end.assign("year", endMoment.year());
    } else {
      result.end.imply("day", endMoment.date());
      result.end.imply("month", endMoment.month() + 1);
      result.end.imply("year", endMoment.year());
    }
    hour = 0;
    minute = 0;
    meridiem = -1;
    if (match[SECOND_GROUP6]) {
      var second = parseInt(match[SECOND_GROUP6]);
      if (isNaN(second)) {
        second = zhStringToNumber2(match[SECOND_GROUP6]);
      }
      if (second >= 60)
        return null;
      result.end.assign("second", second);
    }
    hour = parseInt(match[HOUR_GROUP6]);
    if (isNaN(hour)) {
      hour = zhStringToNumber2(match[HOUR_GROUP6]);
    }
    if (match[MINUTE_GROUP6]) {
      if (match[MINUTE_GROUP6] == "åŠ") {
        minute = 30;
      } else if (match[MINUTE_GROUP6] == "æ­£" || match[MINUTE_GROUP6] == "æ•´") {
        minute = 0;
      } else {
        minute = parseInt(match[MINUTE_GROUP6]);
        if (isNaN(minute)) {
          minute = zhStringToNumber2(match[MINUTE_GROUP6]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match[AM_PM_HOUR_GROUP5]) {
      if (hour > 12)
        return null;
      var ampm = match[AM_PM_HOUR_GROUP5][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem == 0) {
          result.start.imply("meridiem", 0);
          if (result.start.get("hour") == 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", 1);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_12]) {
      var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_12];
      var zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "æœ" || zhAMPM1 == "æ—©") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_22]) {
      var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_22];
      var zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "ä¸Š" || zhAMPM2 == "æœ" || zhAMPM2 == "æ—©" || zhAMPM2 == "å‡Œ") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "ä¸‹" || zhAMPM2 == "æ™" || zhAMPM2 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_32]) {
      var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_32];
      var zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "ä¸Š" || zhAMPM3 == "æœ" || zhAMPM3 == "æ—©" || zhAMPM3 == "å‡Œ") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "ä¸‹" || zhAMPM3 == "æ™" || zhAMPM3 == "æ™š") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.text = result.text + match[0];
    result.end.assign("hour", hour);
    result.end.assign("minute", minute);
    if (meridiem >= 0) {
      result.end.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
      if (startAtPM && result.start.get("hour") > hour) {
        result.end.imply("meridiem", 0);
      } else if (hour > 12) {
        result.end.imply("meridiem", 1);
      }
    }
    if (result.end.date().getTime() < result.start.date().getTime()) {
      result.end.imply("day", result.end.get("day") + 1);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantWeekdayParser.js
var import_dayjs36 = __toESM(require_dayjs_min(), 1);
var PATTERN41 = new RegExp("(?:æ˜ŸæœŸ|ç¦®æ‹œ|é€±)(?<weekday>" + Object.keys(WEEKDAY_OFFSET3).join("|") + ")");
var ZHHantWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN41;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET3[dayOfWeek];
    if (offset === void 0)
      return null;
    let startMoment = (0, import_dayjs36.default)(context.refDate);
    const startMomentFixed = false;
    const refOffset = startMoment.day();
    if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
      startMoment = startMoment.day(offset - 7);
    } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
      startMoment = startMoment.day(offset + 7);
    } else {
      startMoment = startMoment.day(offset);
    }
    result.start.assign("weekday", offset);
    if (startMomentFixed) {
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js
var ZHHantMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(è‡³|åˆ°|\-|\~|ï½ž|ï¼|ãƒ¼)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js
var ZHHantMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/index.js
var hant_exports = {};
__export(hant_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual7,
  createCasualConfiguration: () => createCasualConfiguration6,
  createConfiguration: () => createConfiguration6,
  hant: () => hant,
  parse: () => parse7,
  parseDate: () => parseDate7,
  strict: () => strict7
});
var hant = new Chrono(createCasualConfiguration6());
var casual7 = new Chrono(createCasualConfiguration6());
var strict7 = new Chrono(createConfiguration6());
function parse7(text, ref, option) {
  return casual7.parse(text, ref, option);
}
function parseDate7(text, ref, option) {
  return casual7.parseDate(text, ref, option);
}
function createCasualConfiguration6() {
  const option = createConfiguration6();
  option.parsers.unshift(new ZHHantCasualDateParser());
  return option;
}
function createConfiguration6() {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new ZHHantDateParser(),
      new ZHHantRelationWeekdayParser(),
      new ZHHantWeekdayParser(),
      new ZHHantTimeExpressionParser(),
      new ZHHantDeadlineFormatParser()
    ],
    refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()]
  });
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/zh/hans/index.js
var hans_exports = {};
__export(hans_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual8,
  createCasualConfiguration: () => createCasualConfiguration7,
  createConfiguration: () => createConfiguration7,
  hans: () => hans,
  parse: () => parse8,
  parseDate: () => parseDate8,
  strict: () => strict8
});

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansCasualDateParser.js
var import_dayjs37 = __toESM(require_dayjs_min(), 1);
var NOW_GROUP2 = 1;
var DAY_GROUP_14 = 2;
var TIME_GROUP_12 = 3;
var TIME_GROUP_22 = 4;
var DAY_GROUP_34 = 5;
var TIME_GROUP_32 = 6;
var ZHHansCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return new RegExp("(çŽ°åœ¨|ç«‹(?:åˆ»|å³)|å³åˆ»)|(ä»Š|æ˜Ž|å‰|å¤§å‰|åŽ|å¤§åŽ|æ˜¨)(æ—©|æ™š)|(ä¸Š(?:åˆ)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨))|(ä»Š|æ˜Ž|å‰|å¤§å‰|åŽ|å¤§åŽ|æ˜¨)(?:æ—¥|å¤©)(?:[\\s|,|ï¼Œ]*)(?:(ä¸Š(?:åˆ)|æ—©(?:ä¸Š)|ä¸‹(?:åˆ)|æ™š(?:ä¸Š)|å¤œ(?:æ™š)?|ä¸­(?:åˆ)|å‡Œ(?:æ™¨)))?", "i");
  }
  innerExtract(context, match) {
    const index = match.index;
    const result = context.createParsingResult(index, match[0]);
    const refMoment = (0, import_dayjs37.default)(context.refDate);
    let startMoment = refMoment;
    if (match[NOW_GROUP2]) {
      result.start.imply("hour", refMoment.hour());
      result.start.imply("minute", refMoment.minute());
      result.start.imply("second", refMoment.second());
      result.start.imply("millisecond", refMoment.millisecond());
    } else if (match[DAY_GROUP_14]) {
      const day1 = match[DAY_GROUP_14];
      const time1 = match[TIME_GROUP_12];
      if (day1 == "æ˜Ž") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day1 == "æ˜¨") {
        startMoment = startMoment.add(-1, "day");
      } else if (day1 == "å‰") {
        startMoment = startMoment.add(-2, "day");
      } else if (day1 == "å¤§å‰") {
        startMoment = startMoment.add(-3, "day");
      } else if (day1 == "åŽ") {
        startMoment = startMoment.add(2, "day");
      } else if (day1 == "å¤§åŽ") {
        startMoment = startMoment.add(3, "day");
      }
      if (time1 == "æ—©") {
        result.start.imply("hour", 6);
      } else if (time1 == "æ™š") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      }
    } else if (match[TIME_GROUP_22]) {
      const timeString2 = match[TIME_GROUP_22];
      const time2 = timeString2[0];
      if (time2 == "æ—©" || time2 == "ä¸Š") {
        result.start.imply("hour", 6);
      } else if (time2 == "ä¸‹") {
        result.start.imply("hour", 15);
        result.start.imply("meridiem", 1);
      } else if (time2 == "ä¸­") {
        result.start.imply("hour", 12);
        result.start.imply("meridiem", 1);
      } else if (time2 == "å¤œ" || time2 == "æ™š") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      } else if (time2 == "å‡Œ") {
        result.start.imply("hour", 0);
      }
    } else if (match[DAY_GROUP_34]) {
      const day3 = match[DAY_GROUP_34];
      if (day3 == "æ˜Ž") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day3 == "æ˜¨") {
        startMoment = startMoment.add(-1, "day");
      } else if (day3 == "å‰") {
        startMoment = startMoment.add(-2, "day");
      } else if (day3 == "å¤§å‰") {
        startMoment = startMoment.add(-3, "day");
      } else if (day3 == "åŽ") {
        startMoment = startMoment.add(2, "day");
      } else if (day3 == "å¤§åŽ") {
        startMoment = startMoment.add(3, "day");
      }
      const timeString3 = match[TIME_GROUP_32];
      if (timeString3) {
        const time3 = timeString3[0];
        if (time3 == "æ—©" || time3 == "ä¸Š") {
          result.start.imply("hour", 6);
        } else if (time3 == "ä¸‹") {
          result.start.imply("hour", 15);
          result.start.imply("meridiem", 1);
        } else if (time3 == "ä¸­") {
          result.start.imply("hour", 12);
          result.start.imply("meridiem", 1);
        } else if (time3 == "å¤œ" || time3 == "æ™š") {
          result.start.imply("hour", 22);
          result.start.imply("meridiem", 1);
        } else if (time3 == "å‡Œ") {
          result.start.imply("hour", 0);
        }
      }
    }
    result.start.assign("day", startMoment.date());
    result.start.assign("month", startMoment.month() + 1);
    result.start.assign("year", startMoment.year());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js
var ZHHansMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(è‡³|åˆ°|-|~|ï½ž|ï¼|ãƒ¼)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js
var ZHHansMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/index.js
var hans = new Chrono(createCasualConfiguration7());
var casual8 = new Chrono(createCasualConfiguration7());
var strict8 = new Chrono(createConfiguration7());
function parse8(text, ref, option) {
  return casual8.parse(text, ref, option);
}
function parseDate8(text, ref, option) {
  return casual8.parseDate(text, ref, option);
}
function createCasualConfiguration7() {
  const option = createConfiguration7();
  option.parsers.unshift(new ZHHansCasualDateParser());
  return option;
}
function createConfiguration7() {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new ZHHansDateParser(),
      new ZHHansRelationWeekdayParser(),
      new ZHHansWeekdayParser(),
      new ZHHansTimeExpressionParser(),
      new ZHHansDeadlineFormatParser()
    ],
    refiners: [new ZHHansMergeDateRangeRefiner(), new ZHHansMergeDateTimeRefiner()]
  });
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/zh/index.js
var casual9 = new Chrono(createCasualConfiguration8());
var strict9 = new Chrono(createConfiguration8());
function parse9(text, ref, option) {
  return casual9.parse(text, ref, option);
}
function parseDate9(text, ref, option) {
  return casual9.parseDate(text, ref, option);
}
function createCasualConfiguration8() {
  const option = createConfiguration8();
  option.parsers.unshift(new ZHHantCasualDateParser());
  return option;
}
function createConfiguration8() {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new ZHHantDateParser(),
      new ZHHansDateParser(),
      new ZHHantRelationWeekdayParser(),
      new ZHHansRelationWeekdayParser(),
      new ZHHantWeekdayParser(),
      new ZHHansWeekdayParser(),
      new ZHHantTimeExpressionParser(),
      new ZHHansTimeExpressionParser(),
      new ZHHantDeadlineFormatParser(),
      new ZHHansDeadlineFormatParser()
    ],
    refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()]
  });
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/ru/index.js
var ru_exports = {};
__export(ru_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual10,
  createCasualConfiguration: () => createCasualConfiguration9,
  createConfiguration: () => createConfiguration9,
  parse: () => parse10,
  parseDate: () => parseDate10,
  strict: () => strict10
});

// node_modules/chrono-node/dist/esm/locales/ru/constants.js
var REGEX_PARTS = {
  leftBoundary: "([^\\p{L}\\p{N}_]|^)",
  rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
  flags: "iu"
};
var WEEKDAY_DICTIONARY6 = {
  Ð²Ð¾ÑÐºÑ€ÐµÑÐµÐ½ÑŒÐµ: 0,
  Ð²Ð¾ÑÐºÑ€ÐµÑÐµÐ½ÑŒÑ: 0,
  Ð²ÑÐº: 0,
  "Ð²ÑÐº.": 0,
  Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑŒÐ½Ð¸Ðº: 1,
  Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑŒÐ½Ð¸ÐºÐ°: 1,
  Ð¿Ð½: 1,
  "Ð¿Ð½.": 1,
  Ð²Ñ‚Ð¾Ñ€Ð½Ð¸Ðº: 2,
  Ð²Ñ‚Ð¾Ñ€Ð½Ð¸ÐºÐ°: 2,
  Ð²Ñ‚: 2,
  "Ð²Ñ‚.": 2,
  ÑÑ€ÐµÐ´Ð°: 3,
  ÑÑ€ÐµÐ´Ñ‹: 3,
  ÑÑ€ÐµÐ´Ñƒ: 3,
  ÑÑ€: 3,
  "ÑÑ€.": 3,
  Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð³: 4,
  Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð³Ð°: 4,
  Ñ‡Ñ‚: 4,
  "Ñ‡Ñ‚.": 4,
  Ð¿ÑÑ‚Ð½Ð¸Ñ†Ð°: 5,
  Ð¿ÑÑ‚Ð½Ð¸Ñ†Ñƒ: 5,
  Ð¿ÑÑ‚Ð½Ð¸Ñ†Ñ‹: 5,
  Ð¿Ñ‚: 5,
  "Ð¿Ñ‚.": 5,
  ÑÑƒÐ±Ð±Ð¾Ñ‚Ð°: 6,
  ÑÑƒÐ±Ð±Ð¾Ñ‚Ñƒ: 6,
  ÑÑƒÐ±Ð±Ð¾Ñ‚Ñ‹: 6,
  ÑÐ±: 6,
  "ÑÐ±.": 6
};
var FULL_MONTH_NAME_DICTIONARY2 = {
  ÑÐ½Ð²Ð°Ñ€ÑŒ: 1,
  ÑÐ½Ð²Ð°Ñ€Ñ: 1,
  ÑÐ½Ð²Ð°Ñ€Ðµ: 1,
  Ñ„ÐµÐ²Ñ€Ð°Ð»ÑŒ: 2,
  Ñ„ÐµÐ²Ñ€Ð°Ð»Ñ: 2,
  Ñ„ÐµÐ²Ñ€Ð°Ð»Ðµ: 2,
  Ð¼Ð°Ñ€Ñ‚: 3,
  Ð¼Ð°Ñ€Ñ‚Ð°: 3,
  Ð¼Ð°Ñ€Ñ‚Ðµ: 3,
  Ð°Ð¿Ñ€ÐµÐ»ÑŒ: 4,
  Ð°Ð¿Ñ€ÐµÐ»Ñ: 4,
  Ð°Ð¿Ñ€ÐµÐ»Ðµ: 4,
  Ð¼Ð°Ð¹: 5,
  Ð¼Ð°Ñ: 5,
  Ð¼Ð°Ðµ: 5,
  Ð¸ÑŽÐ½ÑŒ: 6,
  Ð¸ÑŽÐ½Ñ: 6,
  Ð¸ÑŽÐ½Ðµ: 6,
  Ð¸ÑŽÐ»ÑŒ: 7,
  Ð¸ÑŽÐ»Ñ: 7,
  Ð¸ÑŽÐ»Ðµ: 7,
  Ð°Ð²Ð³ÑƒÑÑ‚: 8,
  Ð°Ð²Ð³ÑƒÑÑ‚Ð°: 8,
  Ð°Ð²Ð³ÑƒÑÑ‚Ðµ: 8,
  ÑÐµÐ½Ñ‚ÑÐ±Ñ€ÑŒ: 9,
  ÑÐµÐ½Ñ‚ÑÐ±Ñ€Ñ: 9,
  ÑÐµÐ½Ñ‚ÑÐ±Ñ€Ðµ: 9,
  Ð¾ÐºÑ‚ÑÐ±Ñ€ÑŒ: 10,
  Ð¾ÐºÑ‚ÑÐ±Ñ€Ñ: 10,
  Ð¾ÐºÑ‚ÑÐ±Ñ€Ðµ: 10,
  Ð½Ð¾ÑÐ±Ñ€ÑŒ: 11,
  Ð½Ð¾ÑÐ±Ñ€Ñ: 11,
  Ð½Ð¾ÑÐ±Ñ€Ðµ: 11,
  Ð´ÐµÐºÐ°Ð±Ñ€ÑŒ: 12,
  Ð´ÐµÐºÐ°Ð±Ñ€Ñ: 12,
  Ð´ÐµÐºÐ°Ð±Ñ€Ðµ: 12
};
var MONTH_DICTIONARY6 = {
  ...FULL_MONTH_NAME_DICTIONARY2,
  ÑÐ½Ð²: 1,
  "ÑÐ½Ð².": 1,
  Ñ„ÐµÐ²: 2,
  "Ñ„ÐµÐ².": 2,
  Ð¼Ð°Ñ€: 3,
  "Ð¼Ð°Ñ€.": 3,
  Ð°Ð¿Ñ€: 4,
  "Ð°Ð¿Ñ€.": 4,
  Ð°Ð²Ð³: 8,
  "Ð°Ð²Ð³.": 8,
  ÑÐµÐ½: 9,
  "ÑÐµÐ½.": 9,
  Ð¾ÐºÑ‚: 10,
  "Ð¾ÐºÑ‚.": 10,
  Ð½Ð¾Ñ: 11,
  "Ð½Ð¾Ñ.": 11,
  Ð´ÐµÐº: 12,
  "Ð´ÐµÐº.": 12
};
var INTEGER_WORD_DICTIONARY5 = {
  Ð¾Ð´Ð¸Ð½: 1,
  Ð¾Ð´Ð½Ð°: 1,
  Ð¾Ð´Ð½Ð¾Ð¹: 1,
  Ð¾Ð´Ð½Ñƒ: 1,
  Ð´Ð²Ðµ: 2,
  Ð´Ð²Ð°: 2,
  Ð´Ð²ÑƒÑ…: 2,
  Ñ‚Ñ€Ð¸: 3,
  Ñ‚Ñ€ÐµÑ…: 3,
  Ñ‚Ñ€Ñ‘Ñ…: 3,
  Ñ‡ÐµÑ‚Ñ‹Ñ€Ðµ: 4,
  Ñ‡ÐµÑ‚Ñ‹Ñ€ÐµÑ…: 4,
  Ñ‡ÐµÑ‚Ñ‹Ñ€Ñ‘Ñ…: 4,
  Ð¿ÑÑ‚ÑŒ: 5,
  Ð¿ÑÑ‚Ð¸: 5,
  ÑˆÐµÑÑ‚ÑŒ: 6,
  ÑˆÐµÑÑ‚Ð¸: 6,
  ÑÐµÐ¼ÑŒ: 7,
  ÑÐµÐ¼Ð¸: 7,
  Ð²Ð¾ÑÐµÐ¼ÑŒ: 8,
  Ð²Ð¾ÑÑŒÐ¼Ð¸: 8,
  Ð´ÐµÐ²ÑÑ‚ÑŒ: 9,
  Ð´ÐµÐ²ÑÑ‚Ð¸: 9,
  Ð´ÐµÑÑÑ‚ÑŒ: 10,
  Ð´ÐµÑÑÑ‚Ð¸: 10,
  Ð¾Ð´Ð¸Ð½Ð½Ð°Ð´Ñ†Ð°Ñ‚ÑŒ: 11,
  Ð¾Ð´Ð¸Ð½Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¸: 11,
  Ð´Ð²ÐµÐ½Ð°Ð´Ñ†Ð°Ñ‚ÑŒ: 12,
  Ð´Ð²ÐµÐ½Ð°Ð´Ñ†Ð°Ñ‚Ð¸: 12
};
var ORDINAL_WORD_DICTIONARY3 = {
  Ð¿ÐµÑ€Ð²Ð¾Ðµ: 1,
  Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾: 1,
  Ð²Ñ‚Ð¾Ñ€Ð¾Ðµ: 2,
  Ð²Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾: 2,
  Ñ‚Ñ€ÐµÑ‚ÑŒÐµ: 3,
  Ñ‚Ñ€ÐµÑ‚ÑŒÐµÐ³Ð¾: 3,
  Ñ‡ÐµÑ‚Ð²ÐµÑ€Ñ‚Ð¾Ðµ: 4,
  Ñ‡ÐµÑ‚Ð²ÐµÑ€Ñ‚Ð¾Ð³Ð¾: 4,
  Ð¿ÑÑ‚Ð¾Ðµ: 5,
  Ð¿ÑÑ‚Ð¾Ð³Ð¾: 5,
  ÑˆÐµÑÑ‚Ð¾Ðµ: 6,
  ÑˆÐµÑÑ‚Ð¾Ð³Ð¾: 6,
  ÑÐµÐ´ÑŒÐ¼Ð¾Ðµ: 7,
  ÑÐµÐ´ÑŒÐ¼Ð¾Ð³Ð¾: 7,
  Ð²Ð¾ÑÑŒÐ¼Ð¾Ðµ: 8,
  Ð²Ð¾ÑÑŒÐ¼Ð¾Ð³Ð¾: 8,
  Ð´ÐµÐ²ÑÑ‚Ð¾Ðµ: 9,
  Ð´ÐµÐ²ÑÑ‚Ð¾Ð³Ð¾: 9,
  Ð´ÐµÑÑÑ‚Ð¾Ðµ: 10,
  Ð´ÐµÑÑÑ‚Ð¾Ð³Ð¾: 10,
  Ð¾Ð´Ð¸Ð½Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 11,
  Ð¾Ð´Ð¸Ð½Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 11,
  Ð´Ð²ÐµÐ½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 12,
  Ð´Ð²ÐµÐ½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 12,
  Ñ‚Ñ€Ð¸Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 13,
  Ñ‚Ñ€Ð¸Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 13,
  Ñ‡ÐµÑ‚Ñ‹Ñ€Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 14,
  Ñ‡ÐµÑ‚Ñ‹Ñ€Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 14,
  Ð¿ÑÑ‚Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 15,
  Ð¿ÑÑ‚Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 15,
  ÑˆÐµÑÑ‚Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 16,
  ÑˆÐµÑÑ‚Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 16,
  ÑÐµÐ¼Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 17,
  ÑÐµÐ¼Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 17,
  Ð²Ð¾ÑÐµÐ¼Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 18,
  Ð²Ð¾ÑÐµÐ¼Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 18,
  Ð´ÐµÐ²ÑÑ‚Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 19,
  Ð´ÐµÐ²ÑÑ‚Ð½Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 19,
  Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ðµ: 20,
  Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾: 20,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð¿ÐµÑ€Ð²Ð¾Ðµ": 21,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾": 21,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð²Ñ‚Ð¾Ñ€Ð¾Ðµ": 22,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð²Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾": 22,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ñ‚Ñ€ÐµÑ‚ÑŒÐµ": 23,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ñ‚Ñ€ÐµÑ‚ÑŒÐµÐ³Ð¾": 23,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ñ‡ÐµÑ‚Ð²ÐµÑ€Ñ‚Ð¾Ðµ": 24,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ñ‡ÐµÑ‚Ð²ÐµÑ€Ñ‚Ð¾Ð³Ð¾": 24,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð¿ÑÑ‚Ð¾Ðµ": 25,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð¿ÑÑ‚Ð¾Ð³Ð¾": 25,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ ÑˆÐµÑÑ‚Ð¾Ðµ": 26,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ ÑˆÐµÑÑ‚Ð¾Ð³Ð¾": 26,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ ÑÐµÐ´ÑŒÐ¼Ð¾Ðµ": 27,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ ÑÐµÐ´ÑŒÐ¼Ð¾Ð³Ð¾": 27,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð²Ð¾ÑÑŒÐ¼Ð¾Ðµ": 28,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð²Ð¾ÑÑŒÐ¼Ð¾Ð³Ð¾": 28,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð´ÐµÐ²ÑÑ‚Ð¾Ðµ": 29,
  "Ð´Ð²Ð°Ð´Ñ†Ð°Ñ‚ÑŒ Ð´ÐµÐ²ÑÑ‚Ð¾Ð³Ð¾": 29,
  "Ñ‚Ñ€Ð¸Ð´Ñ†Ð°Ñ‚Ð¾Ðµ": 30,
  "Ñ‚Ñ€Ð¸Ð´Ñ†Ð°Ñ‚Ð¾Ð³Ð¾": 30,
  "Ñ‚Ñ€Ð¸Ð´Ñ†Ð°Ñ‚ÑŒ Ð¿ÐµÑ€Ð²Ð¾Ðµ": 31,
  "Ñ‚Ñ€Ð¸Ð´Ñ†Ð°Ñ‚ÑŒ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾": 31
};
var TIME_UNIT_DICTIONARY5 = {
  ÑÐµÐº: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð°: "second",
  ÑÐµÐºÑƒÐ½Ð´: "second",
  ÑÐµÐºÑƒÐ½Ð´Ñ‹: "second",
  ÑÐµÐºÑƒÐ½Ð´Ñƒ: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð¾Ñ‡ÐºÐ°: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð¾Ñ‡ÐºÐ¸: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð¾Ñ‡ÐµÐº: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð¾Ñ‡ÐºÑƒ: "second",
  Ð¼Ð¸Ð½: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚Ð°: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚Ñ‹: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚Ñƒ: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚Ð¾Ðº: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚ÐºÐ¸: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚ÐºÑƒ: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚Ð¾Ñ‡ÐµÐº: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚Ð¾Ñ‡ÐºÐ¸: "minute",
  Ð¼Ð¸Ð½ÑƒÑ‚Ð¾Ñ‡ÐºÑƒ: "minute",
  Ñ‡Ð°Ñ: "hour",
  Ñ‡Ð°ÑÐ¾Ð²: "hour",
  Ñ‡Ð°ÑÐ°: "hour",
  Ñ‡Ð°ÑÑƒ: "hour",
  Ñ‡Ð°ÑÐ¸ÐºÐ¾Ð²: "hour",
  Ñ‡Ð°ÑÐ¸ÐºÐ°: "hour",
  Ñ‡Ð°ÑÐ¸ÐºÐµ: "hour",
  Ñ‡Ð°ÑÐ¸Ðº: "hour",
  Ð´ÐµÐ½ÑŒ: "d",
  Ð´Ð½Ñ: "d",
  Ð´Ð½ÐµÐ¹: "d",
  ÑÑƒÑ‚Ð¾Ðº: "d",
  ÑÑƒÑ‚ÐºÐ¸: "d",
  Ð½ÐµÐ´ÐµÐ»Ñ: "week",
  Ð½ÐµÐ´ÐµÐ»Ðµ: "week",
  Ð½ÐµÐ´ÐµÐ»Ð¸: "week",
  Ð½ÐµÐ´ÐµÐ»ÑŽ: "week",
  Ð½ÐµÐ´ÐµÐ»ÑŒ: "week",
  Ð½ÐµÐ´ÐµÐ»ÑŒÐºÐµ: "week",
  Ð½ÐµÐ´ÐµÐ»ÑŒÐºÐ¸: "week",
  Ð½ÐµÐ´ÐµÐ»ÐµÐº: "week",
  Ð¼ÐµÑÑÑ†: "month",
  Ð¼ÐµÑÑÑ†Ðµ: "month",
  Ð¼ÐµÑÑÑ†ÐµÐ²: "month",
  Ð¼ÐµÑÑÑ†Ð°: "month",
  ÐºÐ²Ð°Ñ€Ñ‚Ð°Ð»: "quarter",
  ÐºÐ²Ð°Ñ€Ñ‚Ð°Ð»Ðµ: "quarter",
  ÐºÐ²Ð°Ñ€Ñ‚Ð°Ð»Ð¾Ð²: "quarter",
  Ð³Ð¾Ð´: "year",
  Ð³Ð¾Ð´Ð°: "year",
  Ð³Ð¾Ð´Ñƒ: "year",
  Ð³Ð¾Ð´Ð¾Ð²: "year",
  Ð»ÐµÑ‚: "year",
  Ð³Ð¾Ð´Ð¸Ðº: "year",
  Ð³Ð¾Ð´Ð¸ÐºÐ°: "year",
  Ð³Ð¾Ð´Ð¸ÐºÐ¾Ð²: "year"
};
var NUMBER_PATTERN5 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY5)}|[0-9]+|[0-9]+\\.[0-9]+|Ð¿Ð¾Ð»|Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾|Ð¿Ð°Ñ€(?:Ñ‹|Ñƒ)|\\s{0,3})`;
function parseNumberPattern5(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY5[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY5[num];
  }
  if (num.match(/Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾/)) {
    return 3;
  } else if (num.match(/Ð¿Ð¾Ð»/)) {
    return 0.5;
  } else if (num.match(/Ð¿Ð°Ñ€/)) {
    return 2;
  } else if (num === "") {
    return 1;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN4 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY3)}|[0-9]{1,2}(?:Ð³Ð¾|Ð¾Ð³Ð¾|Ðµ|Ð¾Ðµ)?)`;
function parseOrdinalNumberPattern4(match) {
  const num = match.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY3[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY3[num];
  }
  return parseInt(num);
}
var year = "(?:\\s+(?:Ð³Ð¾Ð´Ñƒ|Ð³Ð¾Ð´Ð°|Ð³Ð¾Ð´|Ð³|Ð³.))?";
var YEAR_PATTERN6 = `(?:[1-9][0-9]{0,3}${year}\\s*(?:Ð½.Ñ.|Ð´Ð¾ Ð½.Ñ.|Ð½. Ñ.|Ð´Ð¾ Ð½. Ñ.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;
function parseYear6(match) {
  if (/(Ð³Ð¾Ð´|Ð³Ð¾Ð´Ð°|Ð³|Ð³.)/i.test(match)) {
    match = match.replace(/(Ð³Ð¾Ð´|Ð³Ð¾Ð´Ð°|Ð³|Ð³.)/i, "");
  }
  if (/(Ð´Ð¾ Ð½.Ñ.|Ð´Ð¾ Ð½. Ñ.)/i.test(match)) {
    match = match.replace(/(Ð´Ð¾ Ð½.Ñ.|Ð´Ð¾ Ð½. Ñ.)/i, "");
    return -parseInt(match);
  }
  if (/(Ð½. Ñ.|Ð½.Ñ.)/i.test(match)) {
    match = match.replace(/(Ð½. Ñ.|Ð½.Ñ.)/i, "");
    return parseInt(match);
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN5 = `(${NUMBER_PATTERN5})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY5)})`;
var SINGLE_TIME_UNIT_REGEX5 = new RegExp(SINGLE_TIME_UNIT_PATTERN5, "i");
var TIME_UNITS_PATTERN5 = repeatedTimeunitPattern(`(?:(?:Ð¾ÐºÐ¾Ð»Ð¾|Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð½Ð¾)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN5);
function parseTimeUnits5(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX5.exec(remainingText);
  while (match) {
    collectDateTimeFragment5(fragments, match);
    remainingText = remainingText.substring(match[0].length).trim();
    match = SINGLE_TIME_UNIT_REGEX5.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment5(fragments, match) {
  const num = parseNumberPattern5(match[1]);
  const unit = TIME_UNIT_DICTIONARY5[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeUnitWithinFormatParser.js
var PATTERN42 = `(?:(?:Ð¾ÐºÐ¾Ð»Ð¾|Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð½Ð¾)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN5})${REGEX_PARTS.rightBoundary}`;
var RUTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS.leftBoundary;
  }
  innerPattern(context) {
    return context.option.forwardDate ? new RegExp(PATTERN42, REGEX_PARTS.flags) : new RegExp(`(?:Ð² Ñ‚ÐµÑ‡ÐµÐ½Ð¸Ðµ|Ð² Ñ‚ÐµÑ‡ÐµÐ½Ð¸Ð¸)\\s*${PATTERN42}`, REGEX_PARTS.flags);
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits5(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/AbstractParserWithWordBoundaryChecking.js
var AbstractParserWithLeftBoundaryChecking = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS.leftBoundary;
  }
  innerPattern(context) {
    return new RegExp(this.innerPatternString(context), REGEX_PARTS.flags);
  }
  innerPatternHasChange(context, currentInnerPattern) {
    return false;
  }
};
var AbstractParserWithLeftRightBoundaryChecking = class extends AbstractParserWithLeftBoundaryChecking {
  innerPattern(context) {
    return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS.rightBoundary}`, REGEX_PARTS.flags);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUMonthNameLittleEndianParser.js
var DATE_GROUP9 = 1;
var DATE_TO_GROUP7 = 2;
var MONTH_NAME_GROUP11 = 3;
var YEAR_GROUP16 = 4;
var RUMonthNameLittleEndianParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(?:Ñ)?\\s*(${ORDINAL_NUMBER_PATTERN4})(?:\\s{0,3}(?:Ð¿Ð¾|-|â€“|Ð´Ð¾)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN4}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY6)})(?:(?:-|\\/|,?\\s{0,3})(${YEAR_PATTERN6}(?![^\\s]\\d)))?`;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY6[match[MONTH_NAME_GROUP11].toLowerCase()];
    const day = parseOrdinalNumberPattern4(match[DATE_GROUP9]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP9].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP16]) {
      const yearNumber = parseYear6(match[YEAR_GROUP16]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP7]) {
      const endDate = parseOrdinalNumberPattern4(match[DATE_TO_GROUP7]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUMonthNameParser.js
var MONTH_NAME_GROUP12 = 2;
var YEAR_GROUP17 = 3;
var RUMonthNameParser = class extends AbstractParserWithLeftBoundaryChecking {
  innerPatternString(context) {
    return `((?:Ð²)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY6)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN6})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`;
  }
  innerExtract(context, match) {
    const monthName = match[MONTH_NAME_GROUP12].toLowerCase();
    if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY2[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match.index, match.index + match[0].length);
    result.start.imply("day", 1);
    const month = MONTH_DICTIONARY6[monthName];
    result.start.assign("month", month);
    if (match[YEAR_GROUP17]) {
      const year3 = parseYear6(match[YEAR_GROUP17]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeExpressionParser.js
var RUTimeExpressionParser = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  patternFlags() {
    return REGEX_PARTS.flags;
  }
  primaryPatternLeftBoundary() {
    return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
  }
  followingPhase() {
    return `\\s*(?:\\-|\\â€“|\\~|\\ã€œ|Ð´Ð¾|Ð¸|Ð¿Ð¾|\\?)\\s*`;
  }
  primaryPrefix() {
    return `(?:(?:Ð²|Ñ)\\s*)??`;
  }
  primarySuffix() {
    return `(?:\\s*(?:ÑƒÑ‚Ñ€Ð°|Ð²ÐµÑ‡ÐµÑ€Ð°|Ð¿Ð¾ÑÐ»Ðµ Ð¿Ð¾Ð»ÑƒÐ´Ð½Ñ))?(?!\\/)${REGEX_PARTS.rightBoundary}`;
  }
  extractPrimaryTimeComponents(context, match) {
    const components = super.extractPrimaryTimeComponents(context, match);
    if (components) {
      if (match[0].endsWith("Ð²ÐµÑ‡ÐµÑ€Ð°")) {
        const hour = components.get("hour");
        if (hour >= 6 && hour < 12) {
          components.assign("hour", components.get("hour") + 12);
          components.assign("meridiem", Meridiem.PM);
        } else if (hour < 6) {
          components.assign("meridiem", Meridiem.AM);
        }
      }
      if (match[0].endsWith("Ð¿Ð¾ÑÐ»Ðµ Ð¿Ð¾Ð»ÑƒÐ´Ð½Ñ")) {
        components.assign("meridiem", Meridiem.PM);
        const hour = components.get("hour");
        if (hour >= 0 && hour <= 6) {
          components.assign("hour", components.get("hour") + 12);
        }
      }
      if (match[0].endsWith("ÑƒÑ‚Ñ€Ð°")) {
        components.assign("meridiem", Meridiem.AM);
        const hour = components.get("hour");
        if (hour < 12) {
          components.assign("hour", components.get("hour"));
        }
      }
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeUnitAgoFormatParser.js
var RUTimeUnitAgoFormatParser = class extends AbstractParserWithLeftBoundaryChecking {
  innerPatternString(context) {
    return `(${TIME_UNITS_PATTERN5})\\s{0,5}Ð½Ð°Ð·Ð°Ð´(?=(?:\\W|$))`;
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits5(match[1]);
    const outputTimeUnits = reverseTimeUnits(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/refiners/RUMergeDateRangeRefiner.js
var RUMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(Ð¸ Ð´Ð¾|Ð¸ Ð¿Ð¾|Ð´Ð¾|Ð¿Ð¾|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/refiners/RUMergeDateTimeRefiner.js
var RUMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp(`^\\s*(T|Ð²|,|-)?\\s*$`);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUCasualDateParser.js
var RUCasualDateParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(?:Ñ|ÑÐ¾)?\\s*(ÑÐµÐ³Ð¾Ð´Ð½Ñ|Ð²Ñ‡ÐµÑ€Ð°|Ð·Ð°Ð²Ñ‚Ñ€Ð°|Ð¿Ð¾ÑÐ»ÐµÐ·Ð°Ð²Ñ‚Ñ€Ð°|Ð¿Ð¾ÑÐ»ÐµÐ¿Ð¾ÑÐ»ÐµÐ·Ð°Ð²Ñ‚Ñ€Ð°|Ð¿Ð¾Ð·Ð°Ð¿Ð¾Ð·Ð°Ð²Ñ‡ÐµÑ€Ð°|Ð¿Ð¾Ð·Ð°Ð²Ñ‡ÐµÑ€Ð°)`;
  }
  innerExtract(context, match) {
    const lowerText = match[1].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "ÑÐµÐ³Ð¾Ð´Ð½Ñ":
        return today(context.reference);
      case "Ð²Ñ‡ÐµÑ€Ð°":
        return yesterday(context.reference);
      case "Ð·Ð°Ð²Ñ‚Ñ€Ð°":
        return tomorrow(context.reference);
      case "Ð¿Ð¾ÑÐ»ÐµÐ·Ð°Ð²Ñ‚Ñ€Ð°":
        return theDayAfter(context.reference, 2);
      case "Ð¿Ð¾ÑÐ»ÐµÐ¿Ð¾ÑÐ»ÐµÐ·Ð°Ð²Ñ‚Ñ€Ð°":
        return theDayAfter(context.reference, 3);
      case "Ð¿Ð¾Ð·Ð°Ð²Ñ‡ÐµÑ€Ð°":
        return theDayBefore(context.reference, 2);
      case "Ð¿Ð¾Ð·Ð°Ð¿Ð¾Ð·Ð°Ð²Ñ‡ÐµÑ€Ð°":
        return theDayBefore(context.reference, 3);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUCasualTimeParser.js
var import_dayjs39 = __toESM(require_dayjs_min(), 1);
var RUCasualTimeParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(ÑÐµÐ¹Ñ‡Ð°Ñ|Ð¿Ñ€Ð¾ÑˆÐ»Ñ‹Ð¼\\s*Ð²ÐµÑ‡ÐµÑ€Ð¾Ð¼|Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð¹\\s*Ð½Ð¾Ñ‡ÑŒÑŽ|ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¹\\s*Ð½Ð¾Ñ‡ÑŒÑŽ|ÑÐµÐ³Ð¾Ð´Ð½Ñ\\s*Ð½Ð¾Ñ‡ÑŒÑŽ|ÑÑ‚Ð¾Ð¹\\s*Ð½Ð¾Ñ‡ÑŒÑŽ|Ð½Ð¾Ñ‡ÑŒÑŽ|ÑÑ‚Ð¸Ð¼ ÑƒÑ‚Ñ€Ð¾Ð¼|ÑƒÑ‚Ñ€Ð¾Ð¼|ÑƒÑ‚Ñ€Ð°|Ð²\\s*Ð¿Ð¾Ð»Ð´ÐµÐ½ÑŒ|Ð²ÐµÑ‡ÐµÑ€Ð¾Ð¼|Ð²ÐµÑ‡ÐµÑ€Ð°|Ð²\\s*Ð¿Ð¾Ð»Ð½Ð¾Ñ‡ÑŒ)`;
  }
  innerExtract(context, match) {
    let targetDate = (0, import_dayjs39.default)(context.refDate);
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    if (lowerText === "ÑÐµÐ¹Ñ‡Ð°Ñ") {
      return now(context.reference);
    }
    if (lowerText === "Ð²ÐµÑ‡ÐµÑ€Ð¾Ð¼" || lowerText === "Ð²ÐµÑ‡ÐµÑ€Ð°") {
      return evening(context.reference);
    }
    if (lowerText.endsWith("ÑƒÑ‚Ñ€Ð¾Ð¼") || lowerText.endsWith("ÑƒÑ‚Ñ€Ð°")) {
      return morning(context.reference);
    }
    if (lowerText.match(/Ð²\s*Ð¿Ð¾Ð»Ð´ÐµÐ½ÑŒ/)) {
      return noon(context.reference);
    }
    if (lowerText.match(/Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð¹\s*Ð½Ð¾Ñ‡ÑŒÑŽ/)) {
      return lastNight(context.reference);
    }
    if (lowerText.match(/Ð¿Ñ€Ð¾ÑˆÐ»Ñ‹Ð¼\s*Ð²ÐµÑ‡ÐµÑ€Ð¾Ð¼/)) {
      return yesterdayEvening(context.reference);
    }
    if (lowerText.match(/ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¹\s*Ð½Ð¾Ñ‡ÑŒÑŽ/)) {
      const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
      targetDate = targetDate.add(daysToAdd, "day");
      assignSimilarDate2(component, targetDate);
      component.imply("hour", 0);
    }
    if (lowerText.match(/Ð²\s*Ð¿Ð¾Ð»Ð½Ð¾Ñ‡ÑŒ/) || lowerText.endsWith("Ð½Ð¾Ñ‡ÑŒÑŽ")) {
      return midnight(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUWeekdayParser.js
var PREFIX_GROUP6 = 1;
var WEEKDAY_GROUP6 = 2;
var POSTFIX_GROUP5 = 3;
var RUWeekdayParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(?:(?:,|\\(|ï¼ˆ)\\s*)?(?:Ð²\\s*?)?(?:(ÑÑ‚Ñƒ|ÑÑ‚Ð¾Ñ‚|Ð¿Ñ€Ð¾ÑˆÐ»Ñ‹Ð¹|Ð¿Ñ€Ð¾ÑˆÐ»ÑƒÑŽ|ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¹|ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÑƒÑŽ|ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ³Ð¾)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY6)})(?:\\s*(?:,|\\)|ï¼‰))?(?:\\s*Ð½Ð°\\s*(ÑÑ‚Ð¾Ð¹|Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð¹|ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¹)\\s*Ð½ÐµÐ´ÐµÐ»Ðµ)?`;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP6].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY6[dayOfWeek];
    const prefix = match[PREFIX_GROUP6];
    const postfix = match[POSTFIX_GROUP5];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "Ð¿Ñ€Ð¾ÑˆÐ»Ñ‹Ð¹" || modifierWord == "Ð¿Ñ€Ð¾ÑˆÐ»ÑƒÑŽ" || modifierWord == "Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð¹") {
      modifier = "last";
    } else if (modifierWord == "ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¹" || modifierWord == "ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÑƒÑŽ" || modifierWord == "ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¹" || modifierWord == "ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ³Ð¾") {
      modifier = "next";
    } else if (modifierWord == "ÑÑ‚Ð¾Ñ‚" || modifierWord == "ÑÑ‚Ñƒ" || modifierWord == "ÑÑ‚Ð¾Ð¹") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RURelativeDateFormatParser.js
var import_dayjs40 = __toESM(require_dayjs_min(), 1);
var MODIFIER_WORD_GROUP3 = 1;
var RELATIVE_WORD_GROUP3 = 2;
var RURelativeDateFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(Ð² Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð¼|Ð½Ð° Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð¹|Ð½Ð° ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¹|Ð² ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¼|Ð½Ð° ÑÑ‚Ð¾Ð¹|Ð² ÑÑ‚Ð¾Ð¼)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY5)})`;
  }
  innerExtract(context, match) {
    const modifier = match[MODIFIER_WORD_GROUP3].toLowerCase();
    const unitWord = match[RELATIVE_WORD_GROUP3].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY5[unitWord];
    if (modifier == "Ð½Ð° ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¹" || modifier == "Ð² ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¼") {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "Ð² Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð¼" || modifier == "Ð½Ð° Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð¹") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = (0, import_dayjs40.default)(context.reference.instant);
    if (timeunit.match(/week/i)) {
      date = date.add(-date.get("d"), "d");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.imply("year", date.year());
    } else if (timeunit.match(/month/i)) {
      date = date.add(-date.date() + 1, "d");
      components.imply("day", date.date());
      components.assign("year", date.year());
      components.assign("month", date.month() + 1);
    } else if (timeunit.match(/year/i)) {
      date = date.add(-date.date() + 1, "d");
      date = date.add(-date.month(), "month");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.assign("year", date.year());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js
var RUTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(ÑÑ‚Ð¸|Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ|Ð¿Ñ€Ð¾ÑˆÐ»Ñ‹Ðµ|ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ðµ|Ð¿Ð¾ÑÐ»Ðµ|ÑÐ¿ÑƒÑÑ‚Ñ|Ñ‡ÐµÑ€ÐµÐ·|\\+|-)\\s*(${TIME_UNITS_PATTERN5})`;
  }
  innerExtract(context, match) {
    const prefix = match[1].toLowerCase();
    let timeUnits = parseTimeUnits5(match[2]);
    switch (prefix) {
      case "Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ":
      case "Ð¿Ñ€Ð¾ÑˆÐ»Ñ‹Ðµ":
      case "-":
        timeUnits = reverseTimeUnits(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/index.js
var casual10 = new Chrono(createCasualConfiguration9());
var strict10 = new Chrono(createConfiguration9(true));
function parse10(text, ref, option) {
  return casual10.parse(text, ref, option);
}
function parseDate10(text, ref, option) {
  return casual10.parseDate(text, ref, option);
}
function createCasualConfiguration9() {
  const option = createConfiguration9(false);
  option.parsers.unshift(new RUCasualDateParser());
  option.parsers.unshift(new RUCasualTimeParser());
  option.parsers.unshift(new RUMonthNameParser());
  option.parsers.unshift(new RURelativeDateFormatParser());
  option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser());
  return option;
}
function createConfiguration9(strictMode = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(true),
      new RUTimeUnitWithinFormatParser(),
      new RUMonthNameLittleEndianParser(),
      new RUWeekdayParser(),
      new RUTimeExpressionParser(strictMode),
      new RUTimeUnitAgoFormatParser()
    ],
    refiners: [new RUMergeDateTimeRefiner(), new RUMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/es/index.js
var es_exports = {};
__export(es_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual11,
  createCasualConfiguration: () => createCasualConfiguration10,
  createConfiguration: () => createConfiguration10,
  parse: () => parse11,
  parseDate: () => parseDate11,
  strict: () => strict11
});

// node_modules/chrono-node/dist/esm/locales/es/constants.js
var WEEKDAY_DICTIONARY7 = {
  "domingo": 0,
  "dom": 0,
  "lunes": 1,
  "lun": 1,
  "martes": 2,
  "mar": 2,
  "miÃ©rcoles": 3,
  "miercoles": 3,
  "miÃ©": 3,
  "mie": 3,
  "jueves": 4,
  "jue": 4,
  "viernes": 5,
  "vie": 5,
  "sÃ¡bado": 6,
  "sabado": 6,
  "sÃ¡b": 6,
  "sab": 6
};
var MONTH_DICTIONARY7 = {
  "enero": 1,
  "ene": 1,
  "ene.": 1,
  "febrero": 2,
  "feb": 2,
  "feb.": 2,
  "marzo": 3,
  "mar": 3,
  "mar.": 3,
  "abril": 4,
  "abr": 4,
  "abr.": 4,
  "mayo": 5,
  "may": 5,
  "may.": 5,
  "junio": 6,
  "jun": 6,
  "jun.": 6,
  "julio": 7,
  "jul": 7,
  "jul.": 7,
  "agosto": 8,
  "ago": 8,
  "ago.": 8,
  "septiembre": 9,
  "setiembre": 9,
  "sep": 9,
  "sep.": 9,
  "octubre": 10,
  "oct": 10,
  "oct.": 10,
  "noviembre": 11,
  "nov": 11,
  "nov.": 11,
  "diciembre": 12,
  "dic": 12,
  "dic.": 12
};
var INTEGER_WORD_DICTIONARY6 = {
  "uno": 1,
  "dos": 2,
  "tres": 3,
  "cuatro": 4,
  "cinco": 5,
  "seis": 6,
  "siete": 7,
  "ocho": 8,
  "nueve": 9,
  "diez": 10,
  "once": 11,
  "doce": 12,
  "trece": 13
};
var TIME_UNIT_DICTIONARY6 = {
  "sec": "second",
  "segundo": "second",
  "segundos": "second",
  "min": "minute",
  "mins": "minute",
  "minuto": "minute",
  "minutos": "minute",
  "h": "hour",
  "hr": "hour",
  "hrs": "hour",
  "hora": "hour",
  "horas": "hour",
  "dÃ­a": "d",
  "dÃ­as": "d",
  "semana": "week",
  "semanas": "week",
  "mes": "month",
  "meses": "month",
  "cuarto": "quarter",
  "cuartos": "quarter",
  "aÃ±o": "year",
  "aÃ±os": "year"
};
var NUMBER_PATTERN6 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY6)}|[0-9]+|[0-9]+\\.[0-9]+|un?|uno?|una?|algunos?|unos?|demi-?)`;
function parseNumberPattern6(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY6[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY6[num];
  } else if (num === "un" || num === "una" || num === "uno") {
    return 1;
  } else if (num.match(/algunos?/)) {
    return 3;
  } else if (num.match(/unos?/)) {
    return 3;
  } else if (num.match(/media?/)) {
    return 0.5;
  }
  return parseFloat(num);
}
var YEAR_PATTERN7 = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
function parseYear7(match) {
  if (match.match(/^[0-9]{1,4}$/)) {
    let yearNumber = parseInt(match);
    if (yearNumber < 100) {
      if (yearNumber > 50) {
        yearNumber = yearNumber + 1900;
      } else {
        yearNumber = yearNumber + 2e3;
      }
    }
    return yearNumber;
  }
  if (match.match(/a\.?\s*c\.?/i)) {
    match = match.replace(/a\.?\s*c\.?/i, "");
    return -parseInt(match);
  }
  return parseInt(match);
}
var SINGLE_TIME_UNIT_PATTERN6 = `(${NUMBER_PATTERN6})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY6)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX6 = new RegExp(SINGLE_TIME_UNIT_PATTERN6, "i");
var TIME_UNITS_PATTERN6 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN6);
function parseTimeUnits6(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX6.exec(remainingText);
  while (match) {
    collectDateTimeFragment6(fragments, match);
    remainingText = remainingText.substring(match[0].length);
    match = SINGLE_TIME_UNIT_REGEX6.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment6(fragments, match) {
  const num = parseNumberPattern6(match[1]);
  const unit = TIME_UNIT_DICTIONARY6[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESWeekdayParser.js
var PATTERN43 = new RegExp(`(?:(?:\\,|\\(|\\ï¼ˆ)\\s*)?(?:(este|esta|pasado|pr[oÃ³]ximo)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY7)})(?:\\s*(?:\\,|\\)|\\ï¼‰))?(?:\\s*(este|esta|pasado|pr[Ã³o]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
var PREFIX_GROUP7 = 1;
var WEEKDAY_GROUP7 = 2;
var POSTFIX_GROUP6 = 3;
var ESWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN43;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP7].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY7[dayOfWeek];
    if (weekday === void 0) {
      return null;
    }
    const prefix = match[PREFIX_GROUP7];
    const postfix = match[POSTFIX_GROUP6];
    let norm = prefix || postfix || "";
    norm = norm.toLowerCase();
    let modifier = null;
    if (norm == "pasado") {
      modifier = "this";
    } else if (norm == "prÃ³ximo" || norm == "proximo") {
      modifier = "next";
    } else if (norm == "este") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESTimeExpressionParser.js
var ESTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:aslas|deslas|las?|al?|de|del)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\â€“|\\~|\\ã€œ|a(?:l)?|\\?)\\s*";
  }
};

// node_modules/chrono-node/dist/esm/locales/es/refiners/ESMergeDateTimeRefiner.js
var ESMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(?:,|de|aslas|a)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/es/refiners/ESMergeDateRangeRefiner.js
var ESMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(?:-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESMonthNameLittleEndianParser.js
var PATTERN44 = new RegExp(`([0-9]{1,2})(?:Âº|Âª|Â°)?(?:\\s*(?:desde|de|\\-|\\â€“|ao?|\\s)\\s*([0-9]{1,2})(?:Âº|Âª|Â°)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${matchAnyPattern(MONTH_DICTIONARY7)})(?:\\s*(?:de|,)?\\s*(${YEAR_PATTERN7}))?(?=\\W|$)`, "i");
var DATE_GROUP10 = 1;
var DATE_TO_GROUP8 = 2;
var MONTH_NAME_GROUP13 = 3;
var YEAR_GROUP18 = 4;
var ESMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN44;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY7[match[MONTH_NAME_GROUP13].toLowerCase()];
    const day = parseInt(match[DATE_GROUP10]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP10].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP18]) {
      const yearNumber = parseYear7(match[YEAR_GROUP18]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP8]) {
      const endDate = parseInt(match[DATE_TO_GROUP8]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESCasualDateParser.js
var ESCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(ahora|hoy|maÃ±ana|ayer)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "ahora":
        return now(context.reference);
      case "hoy":
        return today(context.reference);
      case "maÃ±ana":
        return tomorrow(context.reference);
      case "ayer":
        return yesterday(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESCasualTimeParser.js
var import_dayjs42 = __toESM(require_dayjs_min(), 1);
var ESCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return /(?:esta\s*)?(maÃ±ana|tarde|medianoche|mediodia|mediodÃ­a|noche)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const targetDate = (0, import_dayjs42.default)(context.refDate);
    const component = context.createParsingComponents();
    switch (match[1].toLowerCase()) {
      case "tarde":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "noche":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 22);
        break;
      case "maÃ±ana":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "medianoche":
        assignTheNextDay(component, targetDate);
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        break;
      case "mediodia":
      case "mediodÃ­a":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESTimeUnitWithinFormatParser.js
var ESTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:en|por|durante|de|dentro de)\\s*(${TIME_UNITS_PATTERN6})(?=\\W|$)`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits6(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/es/index.js
var casual11 = new Chrono(createCasualConfiguration10());
var strict11 = new Chrono(createConfiguration10(true));
function parse11(text, ref, option) {
  return casual11.parse(text, ref, option);
}
function parseDate11(text, ref, option) {
  return casual11.parseDate(text, ref, option);
}
function createCasualConfiguration10(littleEndian = true) {
  const option = createConfiguration10(false, littleEndian);
  option.parsers.push(new ESCasualDateParser());
  option.parsers.push(new ESCasualTimeParser());
  return option;
}
function createConfiguration10(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new ESWeekdayParser(),
      new ESTimeExpressionParser(),
      new ESMonthNameLittleEndianParser(),
      new ESTimeUnitWithinFormatParser()
    ],
    refiners: [new ESMergeDateTimeRefiner(), new ESMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/uk/index.js
var uk_exports = {};
__export(uk_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual12,
  createCasualConfiguration: () => createCasualConfiguration11,
  createConfiguration: () => createConfiguration11,
  parse: () => parse12,
  parseDate: () => parseDate12,
  strict: () => strict12
});

// node_modules/chrono-node/dist/esm/locales/uk/constants.js
var REGEX_PARTS2 = {
  leftBoundary: "([^\\p{L}\\p{N}_]|^)",
  rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
  flags: "iu"
};
var WEEKDAY_DICTIONARY8 = {
  "Ð½ÐµÐ´Ñ–Ð»Ñ": 0,
  "Ð½ÐµÐ´Ñ–Ð»Ñ–": 0,
  "Ð½ÐµÐ´Ñ–Ð»ÑŽ": 0,
  "Ð½Ð´": 0,
  "Ð½Ð´.": 0,
  "Ð¿Ð¾Ð½ÐµÐ´Ñ–Ð»Ð¾Ðº": 1,
  "Ð¿Ð¾Ð½ÐµÐ´Ñ–Ð»ÐºÐ°": 1,
  "Ð¿Ð½": 1,
  "Ð¿Ð½.": 1,
  "Ð²Ñ–Ð²Ñ‚Ð¾Ñ€Ð¾Ðº": 2,
  "Ð²Ñ–Ð²Ñ‚Ð¾Ñ€ÐºÐ°": 2,
  "Ð²Ñ‚": 2,
  "Ð²Ñ‚.": 2,
  "ÑÐµÑ€ÐµÐ´Ð°": 3,
  "ÑÐµÑ€ÐµÐ´Ð¸": 3,
  "ÑÐµÑ€ÐµÐ´Ñƒ": 3,
  "ÑÑ€": 3,
  "ÑÑ€.": 3,
  "Ñ‡ÐµÑ‚Ð²ÐµÑ€": 4,
  "Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð³Ð°": 4,
  "Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð³Ñƒ": 4,
  "Ñ‡Ñ‚": 4,
  "Ñ‡Ñ‚.": 4,
  "Ð¿'ÑÑ‚Ð½Ð¸Ñ†Ñ": 5,
  "Ð¿'ÑÑ‚Ð½Ð¸Ñ†Ñ–": 5,
  "Ð¿'ÑÑ‚Ð½Ð¸Ñ†ÑŽ": 5,
  "Ð¿Ñ‚": 5,
  "Ð¿Ñ‚.": 5,
  "ÑÑƒÐ±Ð¾Ñ‚Ð°": 6,
  "ÑÑƒÐ±Ð¾Ñ‚Ð¸": 6,
  "ÑÑƒÐ±Ð¾Ñ‚Ñƒ": 6,
  "ÑÐ±": 6,
  "ÑÐ±.": 6
};
var FULL_MONTH_NAME_DICTIONARY3 = {
  "ÑÑ–Ñ‡ÐµÐ½ÑŒ": 1,
  "ÑÑ–Ñ‡Ð½Ñ": 1,
  "ÑÑ–Ñ‡Ð½Ñ–": 1,
  "Ð»ÑŽÑ‚Ð¸Ð¹": 2,
  "Ð»ÑŽÑ‚Ð¾Ð³Ð¾": 2,
  "Ð»ÑŽÑ‚Ð¾Ð¼Ñƒ": 2,
  "Ð±ÐµÑ€ÐµÐ·ÐµÐ½ÑŒ": 3,
  "Ð±ÐµÑ€ÐµÐ·Ð½Ñ": 3,
  "Ð±ÐµÑ€ÐµÐ·Ð½Ñ–": 3,
  "ÐºÐ²Ñ–Ñ‚ÐµÐ½ÑŒ": 4,
  "ÐºÐ²Ñ–Ñ‚Ð½Ñ": 4,
  "ÐºÐ²Ñ–Ñ‚Ð½Ñ–": 4,
  "Ñ‚Ñ€Ð°Ð²ÐµÐ½ÑŒ": 5,
  "Ñ‚Ñ€Ð°Ð²Ð½Ñ": 5,
  "Ñ‚Ñ€Ð°Ð²Ð½Ñ–": 5,
  "Ñ‡ÐµÑ€Ð²ÐµÐ½ÑŒ": 6,
  "Ñ‡ÐµÑ€Ð²Ð½Ñ": 6,
  "Ñ‡ÐµÑ€Ð²Ð½Ñ–": 6,
  "Ð»Ð¸Ð¿ÐµÐ½ÑŒ": 7,
  "Ð»Ð¸Ð¿Ð½Ñ": 7,
  "Ð»Ð¸Ð¿Ð½Ñ–": 7,
  "ÑÐµÑ€Ð¿ÐµÐ½ÑŒ": 8,
  "ÑÐµÑ€Ð¿Ð½Ñ": 8,
  "ÑÐµÑ€Ð¿Ð½Ñ–": 8,
  "Ð²ÐµÑ€ÐµÑÐµÐ½ÑŒ": 9,
  "Ð²ÐµÑ€ÐµÑÐ½Ñ": 9,
  "Ð²ÐµÑ€ÐµÑÐ½Ñ–": 9,
  "Ð¶Ð¾Ð²Ñ‚ÐµÐ½ÑŒ": 10,
  "Ð¶Ð¾Ð²Ñ‚Ð½Ñ": 10,
  "Ð¶Ð¾Ð²Ñ‚Ð½Ñ–": 10,
  "Ð»Ð¸ÑÑ‚Ð¾Ð¿Ð°Ð´": 11,
  "Ð»Ð¸ÑÑ‚Ð¾Ð¿Ð°Ð´Ð°": 11,
  "Ð»Ð¸ÑÑ‚Ð¾Ð¿Ð°Ð´Ñƒ": 11,
  "Ð³Ñ€ÑƒÐ´ÐµÐ½ÑŒ": 12,
  "Ð³Ñ€ÑƒÐ´Ð½Ñ": 12,
  "Ð³Ñ€ÑƒÐ´Ð½Ñ–": 12
};
var MONTH_DICTIONARY8 = {
  ...FULL_MONTH_NAME_DICTIONARY3,
  "ÑÑ–Ñ‡": 1,
  "ÑÑ–Ñ‡.": 1,
  "Ð»ÑŽÑ‚": 2,
  "Ð»ÑŽÑ‚.": 2,
  "Ð±ÐµÑ€": 3,
  "Ð±ÐµÑ€.": 3,
  "ÐºÐ²Ñ–Ñ‚": 4,
  "ÐºÐ²Ñ–Ñ‚.": 4,
  "Ñ‚Ñ€Ð°Ð²": 5,
  "Ñ‚Ñ€Ð°Ð².": 5,
  "Ñ‡ÐµÑ€Ð²": 6,
  "Ñ‡ÐµÑ€Ð².": 6,
  "Ð»Ð¸Ð¿": 7,
  "Ð»Ð¸Ð¿.": 7,
  "ÑÐµÑ€Ð¿": 8,
  "ÑÐµÑ€Ð¿.": 8,
  "ÑÐµÑ€": 8,
  "cÐµÑ€.": 8,
  "Ð²ÐµÑ€": 9,
  "Ð²ÐµÑ€.": 9,
  "Ð²ÐµÑ€ÐµÑ": 9,
  "Ð²ÐµÑ€ÐµÑ.": 9,
  "Ð¶Ð¾Ð²Ñ‚": 10,
  "Ð¶Ð¾Ð²Ñ‚.": 10,
  "Ð»Ð¸ÑÑ‚Ð¾Ð¿": 11,
  "Ð»Ð¸ÑÑ‚Ð¾Ð¿.": 11,
  "Ð³Ñ€ÑƒÐ´": 12,
  "Ð³Ñ€ÑƒÐ´.": 12
};
var INTEGER_WORD_DICTIONARY7 = {
  "Ð¾Ð´Ð¸Ð½": 1,
  "Ð¾Ð´Ð½Ð°": 1,
  "Ð¾Ð´Ð½Ð¾Ñ—": 1,
  "Ð¾Ð´Ð½Ñƒ": 1,
  "Ð´Ð²Ñ–": 2,
  "Ð´Ð²Ð°": 2,
  "Ð´Ð²Ð¾Ñ…": 2,
  "Ñ‚Ñ€Ð¸": 3,
  "Ñ‚Ñ€ÑŒÐ¾Ñ…": 3,
  "Ñ‡Ð¾Ñ‚Ð¸Ñ€Ð¸": 4,
  "Ñ‡Ð¾Ñ‚Ð¸Ñ€ÑŒÐ¾Ñ…": 4,
  "Ð¿'ÑÑ‚ÑŒ": 5,
  "Ð¿'ÑÑ‚Ð¸": 5,
  "ÑˆÑ–ÑÑ‚ÑŒ": 6,
  "ÑˆÐµÑÑ‚Ð¸": 6,
  "ÑÑ–Ð¼": 7,
  "ÑÐµÐ¼Ð¸": 7,
  "Ð²Ñ–ÑÑ–Ð¼": 8,
  "Ð²Ð¾ÑÑŒÐ¼Ð¸": 8,
  "Ð´ÐµÐ²'ÑÑ‚ÑŒ": 9,
  "Ð´ÐµÐ²'ÑÑ‚Ð¸": 9,
  "Ð´ÐµÑÑÑ‚ÑŒ": 10,
  "Ð´ÐµÑÑÑ‚Ð¸": 10,
  "Ð¾Ð´Ð¸Ð½Ð°Ð´Ñ†ÑÑ‚ÑŒ": 11,
  "Ð¾Ð´Ð¸Ð½Ð°Ð´Ñ†ÑÑ‚Ð¸": 11,
  "Ð´Ð²Ð°Ð½Ð°Ð´Ñ†ÑÑ‚ÑŒ": 12,
  "Ð´Ð²Ð°Ð½Ð°Ð´Ñ†ÑÑ‚Ð¸": 12
};
var ORDINAL_WORD_DICTIONARY4 = {
  "Ð¿ÐµÑ€ÑˆÐµ": 1,
  "Ð¿ÐµÑ€ÑˆÐ¾Ð³Ð¾": 1,
  "Ð´Ñ€ÑƒÐ³Ðµ": 2,
  "Ð´Ñ€ÑƒÐ³Ð¾Ð³Ð¾": 2,
  "Ñ‚Ñ€ÐµÑ‚Ñ”": 3,
  "Ñ‚Ñ€ÐµÑ‚ÑŒÐ¾Ð³Ð¾": 3,
  "Ñ‡ÐµÑ‚Ð²ÐµÑ€Ñ‚Ðµ": 4,
  "Ñ‡ÐµÑ‚Ð²ÐµÑ€Ñ‚Ð¾Ð³Ð¾": 4,
  "Ð¿'ÑÑ‚Ðµ": 5,
  "Ð¿'ÑÑ‚Ð¾Ð³Ð¾": 5,
  "ÑˆÐ¾ÑÑ‚Ðµ": 6,
  "ÑˆÐ¾ÑÑ‚Ð¾Ð³Ð¾": 6,
  "ÑÑŒÐ¾Ð¼Ðµ": 7,
  "ÑÑŒÐ¾Ð¼Ð¾Ð³Ð¾": 7,
  "Ð²Ð¾ÑÑŒÐ¼Ðµ": 8,
  "Ð²Ð¾ÑÑŒÐ¼Ð¾Ð³Ð¾": 8,
  "Ð´ÐµÐ²'ÑÑ‚Ðµ": 9,
  "Ð´ÐµÐ²'ÑÑ‚Ð¾Ð³Ð¾": 9,
  "Ð´ÐµÑÑÑ‚Ðµ": 10,
  "Ð´ÐµÑÑÑ‚Ð¾Ð³Ð¾": 10,
  "Ð¾Ð´Ð¸Ð½Ð°Ð´Ñ†ÑÑ‚Ðµ": 11,
  "Ð¾Ð´Ð¸Ð½Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 11,
  "Ð´Ð²Ð°Ð½Ð°Ð´Ñ†ÑÑ‚Ðµ": 12,
  "Ð´Ð²Ð°Ð½Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 12,
  "Ñ‚Ñ€Ð¸Ð½Ð°Ð´Ñ†ÑÑ‚Ðµ": 13,
  "Ñ‚Ñ€Ð¸Ð½Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 13,
  "Ñ‡Ð¾Ñ‚Ð¸Ñ€Ð½Ð°Ð´Ñ†ÑÑ‚Ðµ": 14,
  "Ñ‡Ð¾Ñ‚Ð¸Ð½Ñ€Ð½Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 14,
  "Ð¿'ÑÑ‚Ð½Ð°Ð´Ñ†ÑÑ‚Ðµ": 15,
  "Ð¿'ÑÑ‚Ð½Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 15,
  "ÑˆÑ–ÑÑ‚Ð½Ð°Ð´Ñ†ÑÑ‚Ðµ": 16,
  "ÑˆÑ–ÑÑ‚Ð½Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 16,
  "ÑÑ–Ð¼Ð½Ð°Ð´Ñ†ÑÑ‚Ðµ": 17,
  "ÑÑ–Ð¼Ð½Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 17,
  "Ð²Ñ–ÑÑ–Ð¼Ð½Ð°Ð´Ñ†ÑÑ‚Ðµ": 18,
  "Ð²Ñ–ÑÑ–Ð¼Ð½Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 18,
  "Ð´ÐµÐ²'ÑÑ‚Ð½Ð°Ð´Ñ†ÑÑ‚Ðµ": 19,
  "Ð´ÐµÐ²'ÑÑ‚Ð½Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 19,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚Ðµ": 20,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 20,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð¿ÐµÑ€ÑˆÐµ": 21,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð¿ÐµÑ€ÑˆÐ¾Ð³Ð¾": 21,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð´Ñ€ÑƒÐ³Ðµ": 22,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð´Ñ€ÑƒÐ³Ð¾Ð³Ð¾": 22,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ñ‚Ñ€ÐµÑ‚Ñ”": 23,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ñ‚Ñ€ÐµÑ‚ÑŒÐ¾Ð³Ð¾": 23,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ñ‡ÐµÑ‚Ð²ÐµÑ€Ñ‚Ðµ": 24,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ñ‡ÐµÑ‚Ð²ÐµÑ€Ñ‚Ð¾Ð³Ð¾": 24,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð¿'ÑÑ‚Ðµ": 25,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð¿'ÑÑ‚Ð¾Ð³Ð¾": 25,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ ÑˆÐ¾ÑÑ‚Ðµ": 26,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ ÑˆÐ¾ÑÑ‚Ð¾Ð³Ð¾": 26,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ ÑÑŒÐ¾Ð¼Ðµ": 27,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ ÑÑŒÐ¾Ð¼Ð¾Ð³Ð¾": 27,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð²Ð¾ÑÑŒÐ¼Ðµ": 28,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð²Ð¾ÑÑŒÐ¼Ð¾Ð³Ð¾": 28,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð´ÐµÐ²'ÑÑ‚Ðµ": 29,
  "Ð´Ð²Ð°Ð´Ñ†ÑÑ‚ÑŒ Ð´ÐµÐ²'ÑÑ‚Ð¾Ð³Ð¾": 29,
  "Ñ‚Ñ€Ð¸Ð´Ñ†ÑÑ‚Ðµ": 30,
  "Ñ‚Ñ€Ð¸Ð´Ñ†ÑÑ‚Ð¾Ð³Ð¾": 30,
  "Ñ‚Ñ€Ð¸Ð´Ñ†ÑÑ‚ÑŒ Ð¿ÐµÑ€ÑˆÐµ": 31,
  "Ñ‚Ñ€Ð¸Ð´Ñ†ÑÑ‚ÑŒ Ð¿ÐµÑ€ÑˆÐ¾Ð³Ð¾": 31
};
var TIME_UNIT_DICTIONARY7 = {
  ÑÐµÐº: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð°: "second",
  ÑÐµÐºÑƒÐ½Ð´: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð¸: "second",
  ÑÐµÐºÑƒÐ½Ð´Ñƒ: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð¾Ñ‡Ð¾Ðº: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð¾Ñ‡ÐºÐ¸: "second",
  ÑÐµÐºÑƒÐ½Ð´Ð¾Ñ‡ÐºÑƒ: "second",
  Ñ…Ð²: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð°: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð¸: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½Ñƒ: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð¾Ðº: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½ÐºÐ¸: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½ÐºÑƒ: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð¾Ñ‡Ð¾Ðº: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð¾Ñ‡ÐºÐ¸: "minute",
  Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð¾Ñ‡ÐºÑƒ: "minute",
  Ð³Ð¾Ð´: "hour",
  Ð³Ð¾Ð´Ð¸Ð½Ð°: "hour",
  Ð³Ð¾Ð´Ð¸Ð½: "hour",
  Ð³Ð¾Ð´Ð¸Ð½Ð¸: "hour",
  Ð³Ð¾Ð´Ð¸Ð½Ñƒ: "hour",
  Ð³Ð¾Ð´Ð¸Ð½ÐºÐ°: "hour",
  Ð³Ð¾Ð´Ð¸Ð½Ð¾Ðº: "hour",
  Ð³Ð¾Ð´Ð¸Ð½ÐºÐ¸: "hour",
  Ð³Ð¾Ð´Ð¸Ð½ÐºÑƒ: "hour",
  Ð´ÐµÐ½ÑŒ: "d",
  Ð´Ð½Ñ: "d",
  Ð´Ð½Ñ–Ð²: "d",
  Ð´Ð½Ñ–: "d",
  Ð´Ð¾Ð±Ð°: "d",
  Ð´Ð¾Ð±Ñƒ: "d",
  Ñ‚Ð¸Ð¶Ð´ÐµÐ½ÑŒ: "week",
  Ñ‚Ð¸Ð¶Ð½ÑŽ: "week",
  Ñ‚Ð¸Ð¶Ð½Ñ: "week",
  Ñ‚Ð¸Ð¶Ð½Ñ–: "week",
  Ñ‚Ð¸Ð¶Ð½Ñ–Ð²: "week",
  Ð¼Ñ–ÑÑÑ†ÑŒ: "month",
  Ð¼Ñ–ÑÑÑ†Ñ–Ð²: "month",
  Ð¼Ñ–ÑÑÑ†Ñ–: "month",
  Ð¼Ñ–ÑÑÑ†Ñ: "month",
  ÐºÐ²Ð°Ñ€Ñ‚Ð°Ð»: "quarter",
  ÐºÐ²Ð°Ñ€Ñ‚Ð°Ð»Ñƒ: "quarter",
  ÐºÐ²Ð°Ñ€Ñ‚Ð°Ð»Ð°: "quarter",
  ÐºÐ²Ð°Ñ€Ñ‚Ð°Ð»Ñ–Ð²: "quarter",
  ÐºÐ²Ð°Ñ€Ñ‚Ð°Ð»Ñ–: "quarter",
  Ñ€Ñ–Ðº: "year",
  Ñ€Ð¾ÐºÑƒ: "year",
  Ñ€Ð¾Ñ†Ñ–: "year",
  Ñ€Ð¾ÐºÑ–Ð²: "year",
  Ñ€Ð¾ÐºÐ¸: "year"
};
var NUMBER_PATTERN7 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY7)}|[0-9]+|[0-9]+\\.[0-9]+|Ð¿Ñ–Ð²|Ð´ÐµÐºÑ–Ð»ÑŒÐºÐ°|Ð¿Ð°Ñ€(?:Ñƒ)|\\s{0,3})`;
function parseNumberPattern7(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY7[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY7[num];
  }
  if (num.match(/Ð´ÐµÐºÑ–Ð»ÑŒÐºÐ°/)) {
    return 2;
  } else if (num.match(/Ð¿Ñ–Ð²/)) {
    return 0.5;
  } else if (num.match(/Ð¿Ð°Ñ€/)) {
    return 2;
  } else if (num === "") {
    return 1;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN5 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY4)}|[0-9]{1,2}(?:Ð³Ð¾|Ð¾Ð³Ð¾|Ðµ)?)`;
function parseOrdinalNumberPattern5(match) {
  const num = match.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY4[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY4[num];
  }
  return parseInt(num);
}
var year2 = "(?:\\s+(?:Ñ€Ð¾ÐºÑƒ|Ñ€Ñ–Ðº|Ñ€|Ñ€.))?";
var YEAR_PATTERN8 = `(?:[1-9][0-9]{0,3}${year2}\\s*(?:Ð½.Ðµ.|Ð´Ð¾ Ð½.Ðµ.|Ð½. Ðµ.|Ð´Ð¾ Ð½. Ðµ.)|[1-2][0-9]{3}${year2}|[5-9][0-9]${year2})`;
function parseYearPattern(match) {
  if (/(Ñ€Ñ–Ðº|Ñ€Ð¾ÐºÑƒ|Ñ€|Ñ€.)/i.test(match)) {
    match = match.replace(/(Ñ€Ñ–Ðº|Ñ€Ð¾ÐºÑƒ|Ñ€|Ñ€.)/i, "");
  }
  if (/(Ð´Ð¾ Ð½.Ðµ.|Ð´Ð¾ Ð½. Ðµ.)/i.test(match)) {
    match = match.replace(/(Ð´Ð¾ Ð½.Ðµ.|Ð´Ð¾ Ð½. Ðµ.)/i, "");
    return -parseInt(match);
  }
  if (/(Ð½. Ðµ.|Ð½.Ðµ.)/i.test(match)) {
    match = match.replace(/(Ð½. Ðµ.|Ð½.Ðµ.)/i, "");
    return parseInt(match);
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN7 = `(${NUMBER_PATTERN7})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY7)})`;
var SINGLE_TIME_UNIT_REGEX7 = new RegExp(SINGLE_TIME_UNIT_PATTERN7, "i");
var TIME_UNITS_PATTERN7 = repeatedTimeunitPattern(`(?:(?:Ð±Ð»Ð¸Ð·ÑŒÐºÐ¾|Ð¿Ñ€Ð¸Ð±Ð»Ð¸Ð·Ð½Ð¾)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN7);
function parseTimeUnits7(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX7.exec(remainingText);
  while (match) {
    collectDateTimeFragment7(fragments, match);
    remainingText = remainingText.substring(match[0].length).trim();
    match = SINGLE_TIME_UNIT_REGEX7.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment7(fragments, match) {
  const num = parseNumberPattern7(match[1]);
  const unit = TIME_UNIT_DICTIONARY7[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeUnitWithinFormatParser.js
var PATTERN45 = `(?:(?:Ð¿Ñ€Ð¸Ð±Ð»Ð¸Ð·Ð½Ð¾|Ð¾Ñ€Ñ–Ñ”Ð½Ñ‚Ð¾Ð²Ð½Ð¾)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN7})${REGEX_PARTS2.rightBoundary}`;
var UKTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS2.leftBoundary;
  }
  innerPattern(context) {
    return context.option.forwardDate ? new RegExp(PATTERN45, "i") : new RegExp(`(?:Ð¿Ñ€Ð¾Ñ‚ÑÐ³Ð¾Ð¼|Ð½Ð° Ð¿Ñ€Ð¾Ñ‚ÑÐ·Ñ–|Ð¿Ñ€Ð¾Ñ‚ÑÐ³Ð¾Ð¼|ÑƒÐ¿Ñ€Ð¾Ð´Ð¾Ð²Ð¶|Ð²Ð¿Ñ€Ð¾Ð´Ð¾Ð²Ð¶)\\s*${PATTERN45}`, REGEX_PARTS2.flags);
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits7(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/AbstractParserWithWordBoundaryChecking.js
var AbstractParserWithLeftBoundaryChecking2 = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS2.leftBoundary;
  }
  innerPattern(context) {
    return new RegExp(this.innerPatternString(context), REGEX_PARTS2.flags);
  }
  innerPatternHasChange(context, currentInnerPattern) {
    return false;
  }
};
var AbstractParserWithLeftRightBoundaryChecking2 = class extends AbstractParserWithLeftBoundaryChecking2 {
  innerPattern(context) {
    return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS2.rightBoundary}`, REGEX_PARTS2.flags);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKMonthNameLittleEndianParser.js
var DATE_GROUP11 = 1;
var DATE_TO_GROUP9 = 2;
var MONTH_NAME_GROUP14 = 3;
var YEAR_GROUP19 = 4;
var UKMonthNameLittleEndianParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(?:Ð·|Ñ–Ð·)?\\s*(${ORDINAL_NUMBER_PATTERN5})(?:\\s{0,3}(?:Ð¿Ð¾|-|â€“|Ð´Ð¾)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN5}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY8)})(?:(?:-|\\/|,?\\s{0,3})(${YEAR_PATTERN8}(?![^\\s]\\d)))?`;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY8[match[MONTH_NAME_GROUP14].toLowerCase()];
    const day = parseOrdinalNumberPattern5(match[DATE_GROUP11]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP11].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP19]) {
      const yearNumber = parseYearPattern(match[YEAR_GROUP19]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.reference.instant, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP9]) {
      const endDate = parseOrdinalNumberPattern5(match[DATE_TO_GROUP9]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKMonthNameParser.js
var MONTH_NAME_GROUP15 = 2;
var YEAR_GROUP20 = 3;
var UkMonthNameParser = class extends AbstractParserWithLeftBoundaryChecking2 {
  innerPatternString(context) {
    return `((?:Ð²|Ñƒ)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY8)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN8})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`;
  }
  innerExtract(context, match) {
    const monthName = match[MONTH_NAME_GROUP15].toLowerCase();
    if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY3[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match.index, match.index + match[0].length);
    result.start.imply("day", 1);
    const month = MONTH_DICTIONARY8[monthName];
    result.start.assign("month", month);
    if (match[YEAR_GROUP20]) {
      const year3 = parseYearPattern(match[YEAR_GROUP20]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.reference.instant, 1, month);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeExpressionParser.js
var UKTimeExpressionParser = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  patternFlags() {
    return REGEX_PARTS2.flags;
  }
  primaryPatternLeftBoundary() {
    return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
  }
  followingPhase() {
    return `\\s*(?:\\-|\\â€“|\\~|\\ã€œ|Ð´Ð¾|Ñ–|Ð¿Ð¾|\\?)\\s*`;
  }
  primaryPrefix() {
    return `(?:(?:Ð²|Ñƒ|Ð¾|Ð¾Ð±|Ð·|Ñ–Ð·|Ð²Ñ–Ð´)\\s*)??`;
  }
  primarySuffix() {
    return `(?:\\s*(?:Ñ€Ð°Ð½ÐºÑƒ|Ð²ÐµÑ‡Ð¾Ñ€Ð°|Ð¿Ð¾ Ð¾Ð±Ñ–Ð´Ñ–|Ð¿Ñ–ÑÐ»Ñ Ð¾Ð±Ñ–Ð´Ñƒ))?(?!\\/)${REGEX_PARTS2.rightBoundary}`;
  }
  extractPrimaryTimeComponents(context, match) {
    const components = super.extractPrimaryTimeComponents(context, match);
    if (components) {
      if (match[0].endsWith("Ð²ÐµÑ‡Ð¾Ñ€Ð°")) {
        const hour = components.get("hour");
        if (hour >= 6 && hour < 12) {
          components.assign("hour", components.get("hour") + 12);
          components.assign("meridiem", Meridiem.PM);
        } else if (hour < 6) {
          components.assign("meridiem", Meridiem.AM);
        }
      }
      if (match[0].endsWith("Ð¿Ð¾ Ð¾Ð±Ñ–Ð´Ñ–") || match[0].endsWith("Ð¿Ñ–ÑÐ»Ñ Ð¾Ð±Ñ–Ð´Ñƒ")) {
        components.assign("meridiem", Meridiem.PM);
        const hour = components.get("hour");
        if (hour >= 0 && hour <= 6) {
          components.assign("hour", components.get("hour") + 12);
        }
      }
      if (match[0].endsWith("Ñ€Ð°Ð½ÐºÑƒ")) {
        components.assign("meridiem", Meridiem.AM);
        const hour = components.get("hour");
        if (hour < 12) {
          components.assign("hour", components.get("hour"));
        }
      }
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeUnitAgoFormatParser.js
var UKTimeUnitAgoFormatParser = class extends AbstractParserWithLeftBoundaryChecking2 {
  innerPatternString(context) {
    return `(${TIME_UNITS_PATTERN7})\\s{0,5}Ñ‚Ð¾Ð¼Ñƒ(?=(?:\\W|$))`;
  }
  innerExtract(context, match) {
    const timeUnits = parseTimeUnits7(match[1]);
    const outputTimeUnits = reverseTimeUnits(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/refiners/UKMergeDateRangeRefiner.js
var UKMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(Ñ– Ð´Ð¾|Ñ– Ð¿Ð¾|Ð´Ð¾|Ð¿Ð¾|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/refiners/UKMergeDateTimeRefiner.js
var UKMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp(`^\\s*(T|Ð²|Ñƒ|Ð¾|,|-)?\\s*$`);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKCasualDateParser.js
var UKCasualDateParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(?:Ð·|Ñ–Ð·|Ð²Ñ–Ð´)?\\s*(ÑÑŒÐ¾Ð³Ð¾Ð´Ð½Ñ–|Ð²Ñ‡Ð¾Ñ€Ð°|Ð·Ð°Ð²Ñ‚Ñ€Ð°|Ð¿Ñ–ÑÐ»ÑÐ·Ð°Ð²Ñ‚Ñ€Ð°|Ð¿Ñ–ÑÐ»ÑÐ¿Ñ–ÑÐ»ÑÐ·Ð°Ð²Ñ‚Ñ€Ð°|Ð¿Ð¾Ð·Ð°Ð¿Ð¾Ð·Ð°Ð²Ñ‡Ð¾Ñ€Ð°|Ð¿Ð¾Ð·Ð°Ð²Ñ‡Ð¾Ñ€Ð°)`;
  }
  innerExtract(context, match) {
    const lowerText = match[1].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "ÑÑŒÐ¾Ð³Ð¾Ð´Ð½Ñ–":
        return today(context.reference);
      case "Ð²Ñ‡Ð¾Ñ€Ð°":
        return yesterday(context.reference);
      case "Ð·Ð°Ð²Ñ‚Ñ€Ð°":
        return tomorrow(context.reference);
      case "Ð¿Ñ–ÑÐ»ÑÐ·Ð°Ð²Ñ‚Ñ€Ð°":
        return theDayAfter(context.reference, 2);
      case "Ð¿Ñ–ÑÐ»ÑÐ¿Ñ–ÑÐ»ÑÐ·Ð°Ð²Ñ‚Ñ€Ð°":
        return theDayAfter(context.reference, 3);
      case "Ð¿Ð¾Ð·Ð°Ð²Ñ‡Ð¾Ñ€Ð°":
        return theDayBefore(context.reference, 2);
      case "Ð¿Ð¾Ð·Ð°Ð¿Ð¾Ð·Ð°Ð²Ñ‡Ð¾Ñ€Ð°":
        return theDayBefore(context.reference, 3);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKCasualTimeParser.js
var import_dayjs44 = __toESM(require_dayjs_min(), 1);
var UKCasualTimeParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(Ð·Ð°Ñ€Ð°Ð·|Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð³Ð¾\\s*Ð²ÐµÑ‡Ð¾Ñ€Ð°|Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ñ—\\s*Ð½Ð¾Ñ‡Ñ–|Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ñ—\\s*Ð½Ð¾Ñ‡Ñ–|ÑÑŒÐ¾Ð³Ð¾Ð´Ð½Ñ–\\s*Ð²Ð½Ð¾Ñ‡Ñ–|Ñ†Ñ–Ñ”Ñ—\\s*Ð½Ð¾Ñ‡Ñ–|Ñ†ÑŒÐ¾Ð³Ð¾ Ñ€Ð°Ð½ÐºÑƒ|Ð²Ñ€Ð°Ð½Ñ†Ñ–|Ñ€Ð°Ð½ÐºÑƒ|Ð·Ñ€Ð°Ð½ÐºÑƒ|Ð¾Ð¿Ñ–Ð²Ð´Ð½Ñ–|Ð²Ð²ÐµÑ‡ÐµÑ€Ñ–|Ð²ÐµÑ‡Ð¾Ñ€Ð°|Ð¾Ð¿Ñ–Ð²Ð½Ð¾Ñ‡Ñ–|Ð²Ð½Ð¾Ñ‡Ñ–)`;
  }
  innerExtract(context, match) {
    let targetDate = (0, import_dayjs44.default)(context.reference.instant);
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    if (lowerText === "Ð·Ð°Ñ€Ð°Ð·") {
      return now(context.reference);
    }
    if (lowerText === "Ð²Ð²ÐµÑ‡ÐµÑ€Ñ–" || lowerText === "Ð²ÐµÑ‡Ð¾Ñ€Ð°") {
      return evening(context.reference);
    }
    if (lowerText.endsWith("Ð²Ñ€Ð°Ð½Ñ†Ñ–") || lowerText.endsWith("Ñ€Ð°Ð½ÐºÑƒ") || lowerText.endsWith("Ð·Ñ€Ð°Ð½ÐºÑƒ")) {
      return morning(context.reference);
    }
    if (lowerText.endsWith("Ð¾Ð¿Ñ–Ð²Ð´Ð½Ñ–")) {
      return noon(context.reference);
    }
    if (lowerText.match(/Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ñ—\s*Ð½Ð¾Ñ‡Ñ–/)) {
      return lastNight(context.reference);
    }
    if (lowerText.match(/Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð³Ð¾\s*Ð²ÐµÑ‡Ð¾Ñ€Ð°/)) {
      return yesterdayEvening(context.reference);
    }
    if (lowerText.match(/Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ñ—\s*Ð½Ð¾Ñ‡Ñ–/)) {
      const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
      targetDate = targetDate.add(daysToAdd, "day");
      assignSimilarDate2(component, targetDate);
      component.imply("hour", 1);
    }
    if (lowerText.match(/Ñ†Ñ–Ñ”Ñ—\s*Ð½Ð¾Ñ‡Ñ–/)) {
      return midnight(context.reference);
    }
    if (lowerText.endsWith("Ð¾Ð¿Ñ–Ð²Ð½Ð¾Ñ‡Ñ–") || lowerText.endsWith("Ð²Ð½Ð¾Ñ‡Ñ–")) {
      return midnight(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKWeekdayParser.js
var PREFIX_GROUP8 = 1;
var WEEKDAY_GROUP8 = 2;
var POSTFIX_GROUP7 = 3;
var UKWeekdayParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(?:(?:,|\\(|ï¼ˆ)\\s*)?(?:Ð²\\s*?)?(?:Ñƒ\\s*?)?(?:(Ñ†ÐµÐ¹|Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð³Ð¾|Ð¼Ð¸Ð½ÑƒÐ»Ð¸Ð¹|Ð¿Ð¾Ð¿ÐµÑ€ÐµÐ´Ð½Ñ–Ð¹|Ð¿Ð¾Ð¿ÐµÑ€ÐµÐ´Ð½ÑŒÐ¾Ð³Ð¾|Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð³Ð¾|Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¸Ð¹|Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð¼Ñƒ)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY8)})(?:\\s*(?:,|\\)|ï¼‰))?(?:\\s*(Ð½Ð°|Ñƒ|Ð²)\\s*(Ñ†ÑŒÐ¾Ð¼Ñƒ|Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð¼Ñƒ|Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð¼Ñƒ)\\s*Ñ‚Ð¸Ð¶Ð½Ñ–)?`;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP8].toLocaleLowerCase();
    const weekday = WEEKDAY_DICTIONARY8[dayOfWeek];
    const prefix = match[PREFIX_GROUP8];
    const postfix = match[POSTFIX_GROUP7];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLocaleLowerCase();
    let modifier = null;
    if (modifierWord == "Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð³Ð¾" || modifierWord == "Ð¼Ð¸Ð½ÑƒÐ»Ð¸Ð¹" || modifierWord == "Ð¿Ð¾Ð¿ÐµÑ€ÐµÐ´Ð½Ñ–Ð¹" || modifierWord == "Ð¿Ð¾Ð¿ÐµÑ€ÐµÐ´Ð½ÑŒÐ¾Ð³Ð¾") {
      modifier = "last";
    } else if (modifierWord == "Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð³Ð¾" || modifierWord == "Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¸Ð¹") {
      modifier = "next";
    } else if (modifierWord == "Ñ†ÐµÐ¹" || modifierWord == "Ñ†ÑŒÐ¾Ð³Ð¾" || modifierWord == "Ñ†ÑŒÐ¾Ð¼Ñƒ") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKRelativeDateFormatParser.js
var import_dayjs45 = __toESM(require_dayjs_min(), 1);
var MODIFIER_WORD_GROUP4 = 1;
var RELATIVE_WORD_GROUP4 = 2;
var UKRelativeDateFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(Ð² Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð¼Ñƒ|Ñƒ Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð¼Ñƒ|Ð½Ð° Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð¼Ñƒ|Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð³Ð¾|Ð½Ð° Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð¼Ñƒ|Ð² Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð¼Ñƒ|Ñƒ Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð¼Ñƒ|Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð³Ð¾|Ð½Ð° Ñ†ÑŒÐ¾Ð¼Ñƒ|Ð² Ñ†ÑŒÐ¾Ð¼Ñƒ|Ñƒ Ñ†ÑŒÐ¾Ð¼Ñƒ|Ñ†ÑŒÐ¾Ð³Ð¾)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY7)})(?=\\s*)`;
  }
  innerExtract(context, match) {
    const modifier = match[MODIFIER_WORD_GROUP4].toLowerCase();
    const unitWord = match[RELATIVE_WORD_GROUP4].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY7[unitWord];
    if (modifier == "Ð½Ð° Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð¼Ñƒ" || modifier == "Ð² Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð¼Ñƒ" || modifier == "Ñƒ Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð¼Ñƒ" || modifier == "Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ð³Ð¾") {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "Ð½Ð° Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð¼Ñƒ" || modifier == "Ð² Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð¼Ñƒ" || modifier == "Ñƒ Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð¼Ñƒ" || modifier == "Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ð³Ð¾") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = (0, import_dayjs45.default)(context.reference.instant);
    if (timeunit.match(/week/i)) {
      date = date.add(-date.get("d"), "d");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.imply("year", date.year());
    } else if (timeunit.match(/month/i)) {
      date = date.add(-date.date() + 1, "d");
      components.imply("day", date.date());
      components.assign("year", date.year());
      components.assign("month", date.month() + 1);
    } else if (timeunit.match(/year/i)) {
      date = date.add(-date.date() + 1, "d");
      date = date.add(-date.month(), "month");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.assign("year", date.year());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeUnitCasualRelativeFormatParser.js
var UKTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(Ñ†Ñ–|Ð¾ÑÑ‚Ð°Ð½Ð½Ñ–|Ð¼Ð¸Ð½ÑƒÐ»Ñ–|Ð¼Ð°Ð¹Ð±ÑƒÑ‚Ð½Ñ–|Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ñ–|Ð¿Ñ–ÑÐ»Ñ|Ñ‡ÐµÑ€ÐµÐ·|\\+|-)\\s*(${TIME_UNITS_PATTERN7})`;
  }
  innerExtract(context, match) {
    const prefix = match[1].toLowerCase();
    let timeUnits = parseTimeUnits7(match[3]);
    switch (prefix) {
      case "Ð¾ÑÑ‚Ð°Ð½Ð½Ñ–":
      case "Ð¼Ð¸Ð½ÑƒÐ»Ñ–":
      case "-":
        timeUnits = reverseTimeUnits(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/index.js
var casual12 = new Chrono(createCasualConfiguration11());
var strict12 = new Chrono(createConfiguration11(true));
function createCasualConfiguration11() {
  const option = createConfiguration11(false);
  option.parsers.unshift(new UKCasualDateParser());
  option.parsers.unshift(new UKCasualTimeParser());
  option.parsers.unshift(new UkMonthNameParser());
  option.parsers.unshift(new UKRelativeDateFormatParser());
  option.parsers.unshift(new UKTimeUnitCasualRelativeFormatParser());
  return option;
}
function createConfiguration11(strictMode) {
  return includeCommonConfiguration({
    parsers: [
      new ISOFormatParser(),
      new SlashDateFormatParser(true),
      new UKTimeUnitWithinFormatParser(),
      new UKMonthNameLittleEndianParser(),
      new UKWeekdayParser(),
      new UKTimeExpressionParser(strictMode),
      new UKTimeUnitAgoFormatParser()
    ],
    refiners: [new UKMergeDateTimeRefiner(), new UKMergeDateRangeRefiner()]
  }, strictMode);
}
function parse12(text, ref, option) {
  return casual12.parse(text, ref, option);
}
function parseDate12(text, ref, option) {
  return casual12.parseDate(text, ref, option);
}

// node_modules/chrono-node/dist/esm/index.js
var strict13 = strict;
var casual13 = casual;
function parse13(text, ref, option) {
  return casual13.parse(text, ref, option);
}
function parseDate13(text, ref, option) {
  return casual13.parseDate(text, ref, option);
}
export {
  Chrono,
  Meridiem,
  ParsingComponents,
  ParsingContext,
  ParsingResult,
  ReferenceWithTimezone,
  Weekday,
  casual13 as casual,
  de_exports as de,
  en_exports as en,
  es_exports as es,
  fr_exports as fr,
  ja_exports as ja,
  nl_exports as nl,
  parse13 as parse,
  parseDate13 as parseDate,
  pt_exports as pt,
  ru_exports as ru,
  strict13 as strict,
  uk_exports as uk,
  zh_exports as zh
};
//# sourceMappingURL=chrono-node.js.map
